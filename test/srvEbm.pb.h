// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: srvEbm.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_srvEbm_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_srvEbm_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3013000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3013000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "mhdr.pb.h"
#include "structure.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_srvEbm_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_srvEbm_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_srvEbm_2eproto;
namespace srvEbm {
class AddRbConfigureReq;
class AddRbConfigureReqDefaultTypeInternal;
extern AddRbConfigureReqDefaultTypeInternal _AddRbConfigureReq_default_instance_;
class CreateTunnelReq;
class CreateTunnelReqDefaultTypeInternal;
extern CreateTunnelReqDefaultTypeInternal _CreateTunnelReq_default_instance_;
class DeleteTunnelReq;
class DeleteTunnelReqDefaultTypeInternal;
extern DeleteTunnelReqDefaultTypeInternal _DeleteTunnelReq_default_instance_;
class ModifyTunnelReq;
class ModifyTunnelReqDefaultTypeInternal;
extern ModifyTunnelReqDefaultTypeInternal _ModifyTunnelReq_default_instance_;
class ReqReply;
class ReqReplyDefaultTypeInternal;
extern ReqReplyDefaultTypeInternal _ReqReply_default_instance_;
class SecurityConfigureReq;
class SecurityConfigureReqDefaultTypeInternal;
extern SecurityConfigureReqDefaultTypeInternal _SecurityConfigureReq_default_instance_;
}  // namespace srvEbm
PROTOBUF_NAMESPACE_OPEN
template<> ::srvEbm::AddRbConfigureReq* Arena::CreateMaybeMessage<::srvEbm::AddRbConfigureReq>(Arena*);
template<> ::srvEbm::CreateTunnelReq* Arena::CreateMaybeMessage<::srvEbm::CreateTunnelReq>(Arena*);
template<> ::srvEbm::DeleteTunnelReq* Arena::CreateMaybeMessage<::srvEbm::DeleteTunnelReq>(Arena*);
template<> ::srvEbm::ModifyTunnelReq* Arena::CreateMaybeMessage<::srvEbm::ModifyTunnelReq>(Arena*);
template<> ::srvEbm::ReqReply* Arena::CreateMaybeMessage<::srvEbm::ReqReply>(Arena*);
template<> ::srvEbm::SecurityConfigureReq* Arena::CreateMaybeMessage<::srvEbm::SecurityConfigureReq>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace srvEbm {

enum method : int {
  MethodUnknown = 0,
  MethodSecurityConfigureReq = 1,
  MethodCreateTunnelReq = 2,
  MethodModifyTunnelReq = 3,
  MethodDeleteTunnelReq = 4,
  MethodAddRbConfigureReq = 5,
  MethodReqReply = 6,
  method_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  method_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool method_IsValid(int value);
constexpr method method_MIN = MethodUnknown;
constexpr method method_MAX = MethodReqReply;
constexpr int method_ARRAYSIZE = method_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* method_descriptor();
template<typename T>
inline const std::string& method_Name(T enum_t_value) {
  static_assert(::std::is_same<T, method>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function method_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    method_descriptor(), enum_t_value);
}
inline bool method_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, method* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<method>(
    method_descriptor(), name, value);
}
enum version : int {
  VerUnknown = 0,
  Ver = 1,
  version_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  version_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool version_IsValid(int value);
constexpr version version_MIN = VerUnknown;
constexpr version version_MAX = Ver;
constexpr int version_ARRAYSIZE = version_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* version_descriptor();
template<typename T>
inline const std::string& version_Name(T enum_t_value) {
  static_assert(::std::is_same<T, version>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function version_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    version_descriptor(), enum_t_value);
}
inline bool version_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, version* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<version>(
    version_descriptor(), name, value);
}
// ===================================================================

class SecurityConfigureReq PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:srvEbm.SecurityConfigureReq) */ {
 public:
  inline SecurityConfigureReq() : SecurityConfigureReq(nullptr) {}
  virtual ~SecurityConfigureReq();

  SecurityConfigureReq(const SecurityConfigureReq& from);
  SecurityConfigureReq(SecurityConfigureReq&& from) noexcept
    : SecurityConfigureReq() {
    *this = ::std::move(from);
  }

  inline SecurityConfigureReq& operator=(const SecurityConfigureReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SecurityConfigureReq& operator=(SecurityConfigureReq&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SecurityConfigureReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SecurityConfigureReq* internal_default_instance() {
    return reinterpret_cast<const SecurityConfigureReq*>(
               &_SecurityConfigureReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SecurityConfigureReq& a, SecurityConfigureReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SecurityConfigureReq* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SecurityConfigureReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SecurityConfigureReq* New() const final {
    return CreateMaybeMessage<SecurityConfigureReq>(nullptr);
  }

  SecurityConfigureReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SecurityConfigureReq>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SecurityConfigureReq& from);
  void MergeFrom(const SecurityConfigureReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SecurityConfigureReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "srvEbm.SecurityConfigureReq";
  }
  protected:
  explicit SecurityConfigureReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_srvEbm_2eproto);
    return ::descriptor_table_srvEbm_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHdrFieldNumber = 10,
    kCpUpHdrFieldNumber = 20,
    kSecurityConfigFieldNumber = 30,
  };
  // .mhdr.MsgHdr hdr = 10;
  bool has_hdr() const;
  private:
  bool _internal_has_hdr() const;
  public:
  void clear_hdr();
  const ::mhdr::MsgHdr& hdr() const;
  ::mhdr::MsgHdr* release_hdr();
  ::mhdr::MsgHdr* mutable_hdr();
  void set_allocated_hdr(::mhdr::MsgHdr* hdr);
  private:
  const ::mhdr::MsgHdr& _internal_hdr() const;
  ::mhdr::MsgHdr* _internal_mutable_hdr();
  public:
  void unsafe_arena_set_allocated_hdr(
      ::mhdr::MsgHdr* hdr);
  ::mhdr::MsgHdr* unsafe_arena_release_hdr();

  // .structure.CpUpHdr cp_up_hdr = 20;
  bool has_cp_up_hdr() const;
  private:
  bool _internal_has_cp_up_hdr() const;
  public:
  void clear_cp_up_hdr();
  const ::structure::CpUpHdr& cp_up_hdr() const;
  ::structure::CpUpHdr* release_cp_up_hdr();
  ::structure::CpUpHdr* mutable_cp_up_hdr();
  void set_allocated_cp_up_hdr(::structure::CpUpHdr* cp_up_hdr);
  private:
  const ::structure::CpUpHdr& _internal_cp_up_hdr() const;
  ::structure::CpUpHdr* _internal_mutable_cp_up_hdr();
  public:
  void unsafe_arena_set_allocated_cp_up_hdr(
      ::structure::CpUpHdr* cp_up_hdr);
  ::structure::CpUpHdr* unsafe_arena_release_cp_up_hdr();

  // .structure.SecurityConfigure security_config = 30;
  bool has_security_config() const;
  private:
  bool _internal_has_security_config() const;
  public:
  void clear_security_config();
  const ::structure::SecurityConfigure& security_config() const;
  ::structure::SecurityConfigure* release_security_config();
  ::structure::SecurityConfigure* mutable_security_config();
  void set_allocated_security_config(::structure::SecurityConfigure* security_config);
  private:
  const ::structure::SecurityConfigure& _internal_security_config() const;
  ::structure::SecurityConfigure* _internal_mutable_security_config();
  public:
  void unsafe_arena_set_allocated_security_config(
      ::structure::SecurityConfigure* security_config);
  ::structure::SecurityConfigure* unsafe_arena_release_security_config();

  // @@protoc_insertion_point(class_scope:srvEbm.SecurityConfigureReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::mhdr::MsgHdr* hdr_;
  ::structure::CpUpHdr* cp_up_hdr_;
  ::structure::SecurityConfigure* security_config_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_srvEbm_2eproto;
};
// -------------------------------------------------------------------

class CreateTunnelReq PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:srvEbm.CreateTunnelReq) */ {
 public:
  inline CreateTunnelReq() : CreateTunnelReq(nullptr) {}
  virtual ~CreateTunnelReq();

  CreateTunnelReq(const CreateTunnelReq& from);
  CreateTunnelReq(CreateTunnelReq&& from) noexcept
    : CreateTunnelReq() {
    *this = ::std::move(from);
  }

  inline CreateTunnelReq& operator=(const CreateTunnelReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTunnelReq& operator=(CreateTunnelReq&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CreateTunnelReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateTunnelReq* internal_default_instance() {
    return reinterpret_cast<const CreateTunnelReq*>(
               &_CreateTunnelReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CreateTunnelReq& a, CreateTunnelReq& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateTunnelReq* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateTunnelReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateTunnelReq* New() const final {
    return CreateMaybeMessage<CreateTunnelReq>(nullptr);
  }

  CreateTunnelReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateTunnelReq>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CreateTunnelReq& from);
  void MergeFrom(const CreateTunnelReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateTunnelReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "srvEbm.CreateTunnelReq";
  }
  protected:
  explicit CreateTunnelReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_srvEbm_2eproto);
    return ::descriptor_table_srvEbm_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHdrFieldNumber = 10,
    kCpUpHdrFieldNumber = 20,
    kGtpTnlInfoFieldNumber = 30,
  };
  // .mhdr.MsgHdr hdr = 10;
  bool has_hdr() const;
  private:
  bool _internal_has_hdr() const;
  public:
  void clear_hdr();
  const ::mhdr::MsgHdr& hdr() const;
  ::mhdr::MsgHdr* release_hdr();
  ::mhdr::MsgHdr* mutable_hdr();
  void set_allocated_hdr(::mhdr::MsgHdr* hdr);
  private:
  const ::mhdr::MsgHdr& _internal_hdr() const;
  ::mhdr::MsgHdr* _internal_mutable_hdr();
  public:
  void unsafe_arena_set_allocated_hdr(
      ::mhdr::MsgHdr* hdr);
  ::mhdr::MsgHdr* unsafe_arena_release_hdr();

  // .structure.CpUpHdr cp_up_hdr = 20;
  bool has_cp_up_hdr() const;
  private:
  bool _internal_has_cp_up_hdr() const;
  public:
  void clear_cp_up_hdr();
  const ::structure::CpUpHdr& cp_up_hdr() const;
  ::structure::CpUpHdr* release_cp_up_hdr();
  ::structure::CpUpHdr* mutable_cp_up_hdr();
  void set_allocated_cp_up_hdr(::structure::CpUpHdr* cp_up_hdr);
  private:
  const ::structure::CpUpHdr& _internal_cp_up_hdr() const;
  ::structure::CpUpHdr* _internal_mutable_cp_up_hdr();
  public:
  void unsafe_arena_set_allocated_cp_up_hdr(
      ::structure::CpUpHdr* cp_up_hdr);
  ::structure::CpUpHdr* unsafe_arena_release_cp_up_hdr();

  // .structure.GtpTunInfo gtp_tnl_info = 30;
  bool has_gtp_tnl_info() const;
  private:
  bool _internal_has_gtp_tnl_info() const;
  public:
  void clear_gtp_tnl_info();
  const ::structure::GtpTunInfo& gtp_tnl_info() const;
  ::structure::GtpTunInfo* release_gtp_tnl_info();
  ::structure::GtpTunInfo* mutable_gtp_tnl_info();
  void set_allocated_gtp_tnl_info(::structure::GtpTunInfo* gtp_tnl_info);
  private:
  const ::structure::GtpTunInfo& _internal_gtp_tnl_info() const;
  ::structure::GtpTunInfo* _internal_mutable_gtp_tnl_info();
  public:
  void unsafe_arena_set_allocated_gtp_tnl_info(
      ::structure::GtpTunInfo* gtp_tnl_info);
  ::structure::GtpTunInfo* unsafe_arena_release_gtp_tnl_info();

  // @@protoc_insertion_point(class_scope:srvEbm.CreateTunnelReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::mhdr::MsgHdr* hdr_;
  ::structure::CpUpHdr* cp_up_hdr_;
  ::structure::GtpTunInfo* gtp_tnl_info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_srvEbm_2eproto;
};
// -------------------------------------------------------------------

class ModifyTunnelReq PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:srvEbm.ModifyTunnelReq) */ {
 public:
  inline ModifyTunnelReq() : ModifyTunnelReq(nullptr) {}
  virtual ~ModifyTunnelReq();

  ModifyTunnelReq(const ModifyTunnelReq& from);
  ModifyTunnelReq(ModifyTunnelReq&& from) noexcept
    : ModifyTunnelReq() {
    *this = ::std::move(from);
  }

  inline ModifyTunnelReq& operator=(const ModifyTunnelReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModifyTunnelReq& operator=(ModifyTunnelReq&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModifyTunnelReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModifyTunnelReq* internal_default_instance() {
    return reinterpret_cast<const ModifyTunnelReq*>(
               &_ModifyTunnelReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ModifyTunnelReq& a, ModifyTunnelReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ModifyTunnelReq* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModifyTunnelReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModifyTunnelReq* New() const final {
    return CreateMaybeMessage<ModifyTunnelReq>(nullptr);
  }

  ModifyTunnelReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModifyTunnelReq>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModifyTunnelReq& from);
  void MergeFrom(const ModifyTunnelReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModifyTunnelReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "srvEbm.ModifyTunnelReq";
  }
  protected:
  explicit ModifyTunnelReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_srvEbm_2eproto);
    return ::descriptor_table_srvEbm_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHdrFieldNumber = 10,
    kCpUpHdrFieldNumber = 20,
    kGtpTnlInfoFieldNumber = 30,
  };
  // .mhdr.MsgHdr hdr = 10;
  bool has_hdr() const;
  private:
  bool _internal_has_hdr() const;
  public:
  void clear_hdr();
  const ::mhdr::MsgHdr& hdr() const;
  ::mhdr::MsgHdr* release_hdr();
  ::mhdr::MsgHdr* mutable_hdr();
  void set_allocated_hdr(::mhdr::MsgHdr* hdr);
  private:
  const ::mhdr::MsgHdr& _internal_hdr() const;
  ::mhdr::MsgHdr* _internal_mutable_hdr();
  public:
  void unsafe_arena_set_allocated_hdr(
      ::mhdr::MsgHdr* hdr);
  ::mhdr::MsgHdr* unsafe_arena_release_hdr();

  // .structure.CpUpHdr cp_up_hdr = 20;
  bool has_cp_up_hdr() const;
  private:
  bool _internal_has_cp_up_hdr() const;
  public:
  void clear_cp_up_hdr();
  const ::structure::CpUpHdr& cp_up_hdr() const;
  ::structure::CpUpHdr* release_cp_up_hdr();
  ::structure::CpUpHdr* mutable_cp_up_hdr();
  void set_allocated_cp_up_hdr(::structure::CpUpHdr* cp_up_hdr);
  private:
  const ::structure::CpUpHdr& _internal_cp_up_hdr() const;
  ::structure::CpUpHdr* _internal_mutable_cp_up_hdr();
  public:
  void unsafe_arena_set_allocated_cp_up_hdr(
      ::structure::CpUpHdr* cp_up_hdr);
  ::structure::CpUpHdr* unsafe_arena_release_cp_up_hdr();

  // .structure.GtpTunInfo gtp_tnl_info = 30;
  bool has_gtp_tnl_info() const;
  private:
  bool _internal_has_gtp_tnl_info() const;
  public:
  void clear_gtp_tnl_info();
  const ::structure::GtpTunInfo& gtp_tnl_info() const;
  ::structure::GtpTunInfo* release_gtp_tnl_info();
  ::structure::GtpTunInfo* mutable_gtp_tnl_info();
  void set_allocated_gtp_tnl_info(::structure::GtpTunInfo* gtp_tnl_info);
  private:
  const ::structure::GtpTunInfo& _internal_gtp_tnl_info() const;
  ::structure::GtpTunInfo* _internal_mutable_gtp_tnl_info();
  public:
  void unsafe_arena_set_allocated_gtp_tnl_info(
      ::structure::GtpTunInfo* gtp_tnl_info);
  ::structure::GtpTunInfo* unsafe_arena_release_gtp_tnl_info();

  // @@protoc_insertion_point(class_scope:srvEbm.ModifyTunnelReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::mhdr::MsgHdr* hdr_;
  ::structure::CpUpHdr* cp_up_hdr_;
  ::structure::GtpTunInfo* gtp_tnl_info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_srvEbm_2eproto;
};
// -------------------------------------------------------------------

class DeleteTunnelReq PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:srvEbm.DeleteTunnelReq) */ {
 public:
  inline DeleteTunnelReq() : DeleteTunnelReq(nullptr) {}
  virtual ~DeleteTunnelReq();

  DeleteTunnelReq(const DeleteTunnelReq& from);
  DeleteTunnelReq(DeleteTunnelReq&& from) noexcept
    : DeleteTunnelReq() {
    *this = ::std::move(from);
  }

  inline DeleteTunnelReq& operator=(const DeleteTunnelReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteTunnelReq& operator=(DeleteTunnelReq&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeleteTunnelReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteTunnelReq* internal_default_instance() {
    return reinterpret_cast<const DeleteTunnelReq*>(
               &_DeleteTunnelReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DeleteTunnelReq& a, DeleteTunnelReq& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteTunnelReq* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteTunnelReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteTunnelReq* New() const final {
    return CreateMaybeMessage<DeleteTunnelReq>(nullptr);
  }

  DeleteTunnelReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteTunnelReq>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeleteTunnelReq& from);
  void MergeFrom(const DeleteTunnelReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteTunnelReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "srvEbm.DeleteTunnelReq";
  }
  protected:
  explicit DeleteTunnelReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_srvEbm_2eproto);
    return ::descriptor_table_srvEbm_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHdrFieldNumber = 10,
    kCpUpHdrFieldNumber = 20,
  };
  // .mhdr.MsgHdr hdr = 10;
  bool has_hdr() const;
  private:
  bool _internal_has_hdr() const;
  public:
  void clear_hdr();
  const ::mhdr::MsgHdr& hdr() const;
  ::mhdr::MsgHdr* release_hdr();
  ::mhdr::MsgHdr* mutable_hdr();
  void set_allocated_hdr(::mhdr::MsgHdr* hdr);
  private:
  const ::mhdr::MsgHdr& _internal_hdr() const;
  ::mhdr::MsgHdr* _internal_mutable_hdr();
  public:
  void unsafe_arena_set_allocated_hdr(
      ::mhdr::MsgHdr* hdr);
  ::mhdr::MsgHdr* unsafe_arena_release_hdr();

  // .structure.CpUpHdr cp_up_hdr = 20;
  bool has_cp_up_hdr() const;
  private:
  bool _internal_has_cp_up_hdr() const;
  public:
  void clear_cp_up_hdr();
  const ::structure::CpUpHdr& cp_up_hdr() const;
  ::structure::CpUpHdr* release_cp_up_hdr();
  ::structure::CpUpHdr* mutable_cp_up_hdr();
  void set_allocated_cp_up_hdr(::structure::CpUpHdr* cp_up_hdr);
  private:
  const ::structure::CpUpHdr& _internal_cp_up_hdr() const;
  ::structure::CpUpHdr* _internal_mutable_cp_up_hdr();
  public:
  void unsafe_arena_set_allocated_cp_up_hdr(
      ::structure::CpUpHdr* cp_up_hdr);
  ::structure::CpUpHdr* unsafe_arena_release_cp_up_hdr();

  // @@protoc_insertion_point(class_scope:srvEbm.DeleteTunnelReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::mhdr::MsgHdr* hdr_;
  ::structure::CpUpHdr* cp_up_hdr_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_srvEbm_2eproto;
};
// -------------------------------------------------------------------

class AddRbConfigureReq PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:srvEbm.AddRbConfigureReq) */ {
 public:
  inline AddRbConfigureReq() : AddRbConfigureReq(nullptr) {}
  virtual ~AddRbConfigureReq();

  AddRbConfigureReq(const AddRbConfigureReq& from);
  AddRbConfigureReq(AddRbConfigureReq&& from) noexcept
    : AddRbConfigureReq() {
    *this = ::std::move(from);
  }

  inline AddRbConfigureReq& operator=(const AddRbConfigureReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddRbConfigureReq& operator=(AddRbConfigureReq&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AddRbConfigureReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddRbConfigureReq* internal_default_instance() {
    return reinterpret_cast<const AddRbConfigureReq*>(
               &_AddRbConfigureReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AddRbConfigureReq& a, AddRbConfigureReq& b) {
    a.Swap(&b);
  }
  inline void Swap(AddRbConfigureReq* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddRbConfigureReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AddRbConfigureReq* New() const final {
    return CreateMaybeMessage<AddRbConfigureReq>(nullptr);
  }

  AddRbConfigureReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AddRbConfigureReq>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AddRbConfigureReq& from);
  void MergeFrom(const AddRbConfigureReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddRbConfigureReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "srvEbm.AddRbConfigureReq";
  }
  protected:
  explicit AddRbConfigureReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_srvEbm_2eproto);
    return ::descriptor_table_srvEbm_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHdrFieldNumber = 10,
    kCpUpHdrFieldNumber = 20,
    kPdcpConfigureFieldNumber = 30,
  };
  // .mhdr.MsgHdr hdr = 10;
  bool has_hdr() const;
  private:
  bool _internal_has_hdr() const;
  public:
  void clear_hdr();
  const ::mhdr::MsgHdr& hdr() const;
  ::mhdr::MsgHdr* release_hdr();
  ::mhdr::MsgHdr* mutable_hdr();
  void set_allocated_hdr(::mhdr::MsgHdr* hdr);
  private:
  const ::mhdr::MsgHdr& _internal_hdr() const;
  ::mhdr::MsgHdr* _internal_mutable_hdr();
  public:
  void unsafe_arena_set_allocated_hdr(
      ::mhdr::MsgHdr* hdr);
  ::mhdr::MsgHdr* unsafe_arena_release_hdr();

  // .structure.CpUpHdr cp_up_hdr = 20;
  bool has_cp_up_hdr() const;
  private:
  bool _internal_has_cp_up_hdr() const;
  public:
  void clear_cp_up_hdr();
  const ::structure::CpUpHdr& cp_up_hdr() const;
  ::structure::CpUpHdr* release_cp_up_hdr();
  ::structure::CpUpHdr* mutable_cp_up_hdr();
  void set_allocated_cp_up_hdr(::structure::CpUpHdr* cp_up_hdr);
  private:
  const ::structure::CpUpHdr& _internal_cp_up_hdr() const;
  ::structure::CpUpHdr* _internal_mutable_cp_up_hdr();
  public:
  void unsafe_arena_set_allocated_cp_up_hdr(
      ::structure::CpUpHdr* cp_up_hdr);
  ::structure::CpUpHdr* unsafe_arena_release_cp_up_hdr();

  // .structure.PDCPConfigure pdcp_configure = 30;
  bool has_pdcp_configure() const;
  private:
  bool _internal_has_pdcp_configure() const;
  public:
  void clear_pdcp_configure();
  const ::structure::PDCPConfigure& pdcp_configure() const;
  ::structure::PDCPConfigure* release_pdcp_configure();
  ::structure::PDCPConfigure* mutable_pdcp_configure();
  void set_allocated_pdcp_configure(::structure::PDCPConfigure* pdcp_configure);
  private:
  const ::structure::PDCPConfigure& _internal_pdcp_configure() const;
  ::structure::PDCPConfigure* _internal_mutable_pdcp_configure();
  public:
  void unsafe_arena_set_allocated_pdcp_configure(
      ::structure::PDCPConfigure* pdcp_configure);
  ::structure::PDCPConfigure* unsafe_arena_release_pdcp_configure();

  // @@protoc_insertion_point(class_scope:srvEbm.AddRbConfigureReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::mhdr::MsgHdr* hdr_;
  ::structure::CpUpHdr* cp_up_hdr_;
  ::structure::PDCPConfigure* pdcp_configure_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_srvEbm_2eproto;
};
// -------------------------------------------------------------------

class ReqReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:srvEbm.ReqReply) */ {
 public:
  inline ReqReply() : ReqReply(nullptr) {}
  virtual ~ReqReply();

  ReqReply(const ReqReply& from);
  ReqReply(ReqReply&& from) noexcept
    : ReqReply() {
    *this = ::std::move(from);
  }

  inline ReqReply& operator=(const ReqReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReqReply& operator=(ReqReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReqReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReqReply* internal_default_instance() {
    return reinterpret_cast<const ReqReply*>(
               &_ReqReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ReqReply& a, ReqReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ReqReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReqReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReqReply* New() const final {
    return CreateMaybeMessage<ReqReply>(nullptr);
  }

  ReqReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReqReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReqReply& from);
  void MergeFrom(const ReqReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReqReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "srvEbm.ReqReply";
  }
  protected:
  explicit ReqReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_srvEbm_2eproto);
    return ::descriptor_table_srvEbm_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHdrFieldNumber = 10,
  };
  // .mhdr.MsgHdr hdr = 10;
  bool has_hdr() const;
  private:
  bool _internal_has_hdr() const;
  public:
  void clear_hdr();
  const ::mhdr::MsgHdr& hdr() const;
  ::mhdr::MsgHdr* release_hdr();
  ::mhdr::MsgHdr* mutable_hdr();
  void set_allocated_hdr(::mhdr::MsgHdr* hdr);
  private:
  const ::mhdr::MsgHdr& _internal_hdr() const;
  ::mhdr::MsgHdr* _internal_mutable_hdr();
  public:
  void unsafe_arena_set_allocated_hdr(
      ::mhdr::MsgHdr* hdr);
  ::mhdr::MsgHdr* unsafe_arena_release_hdr();

  // @@protoc_insertion_point(class_scope:srvEbm.ReqReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::mhdr::MsgHdr* hdr_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_srvEbm_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SecurityConfigureReq

// .mhdr.MsgHdr hdr = 10;
inline bool SecurityConfigureReq::_internal_has_hdr() const {
  return this != internal_default_instance() && hdr_ != nullptr;
}
inline bool SecurityConfigureReq::has_hdr() const {
  return _internal_has_hdr();
}
inline const ::mhdr::MsgHdr& SecurityConfigureReq::_internal_hdr() const {
  const ::mhdr::MsgHdr* p = hdr_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mhdr::MsgHdr*>(
      &::mhdr::_MsgHdr_default_instance_);
}
inline const ::mhdr::MsgHdr& SecurityConfigureReq::hdr() const {
  // @@protoc_insertion_point(field_get:srvEbm.SecurityConfigureReq.hdr)
  return _internal_hdr();
}
inline void SecurityConfigureReq::unsafe_arena_set_allocated_hdr(
    ::mhdr::MsgHdr* hdr) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hdr_);
  }
  hdr_ = hdr;
  if (hdr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:srvEbm.SecurityConfigureReq.hdr)
}
inline ::mhdr::MsgHdr* SecurityConfigureReq::release_hdr() {
  
  ::mhdr::MsgHdr* temp = hdr_;
  hdr_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mhdr::MsgHdr* SecurityConfigureReq::unsafe_arena_release_hdr() {
  // @@protoc_insertion_point(field_release:srvEbm.SecurityConfigureReq.hdr)
  
  ::mhdr::MsgHdr* temp = hdr_;
  hdr_ = nullptr;
  return temp;
}
inline ::mhdr::MsgHdr* SecurityConfigureReq::_internal_mutable_hdr() {
  
  if (hdr_ == nullptr) {
    auto* p = CreateMaybeMessage<::mhdr::MsgHdr>(GetArena());
    hdr_ = p;
  }
  return hdr_;
}
inline ::mhdr::MsgHdr* SecurityConfigureReq::mutable_hdr() {
  // @@protoc_insertion_point(field_mutable:srvEbm.SecurityConfigureReq.hdr)
  return _internal_mutable_hdr();
}
inline void SecurityConfigureReq::set_allocated_hdr(::mhdr::MsgHdr* hdr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(hdr_);
  }
  if (hdr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hdr)->GetArena();
    if (message_arena != submessage_arena) {
      hdr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hdr, submessage_arena);
    }
    
  } else {
    
  }
  hdr_ = hdr;
  // @@protoc_insertion_point(field_set_allocated:srvEbm.SecurityConfigureReq.hdr)
}

// .structure.CpUpHdr cp_up_hdr = 20;
inline bool SecurityConfigureReq::_internal_has_cp_up_hdr() const {
  return this != internal_default_instance() && cp_up_hdr_ != nullptr;
}
inline bool SecurityConfigureReq::has_cp_up_hdr() const {
  return _internal_has_cp_up_hdr();
}
inline const ::structure::CpUpHdr& SecurityConfigureReq::_internal_cp_up_hdr() const {
  const ::structure::CpUpHdr* p = cp_up_hdr_;
  return p != nullptr ? *p : *reinterpret_cast<const ::structure::CpUpHdr*>(
      &::structure::_CpUpHdr_default_instance_);
}
inline const ::structure::CpUpHdr& SecurityConfigureReq::cp_up_hdr() const {
  // @@protoc_insertion_point(field_get:srvEbm.SecurityConfigureReq.cp_up_hdr)
  return _internal_cp_up_hdr();
}
inline void SecurityConfigureReq::unsafe_arena_set_allocated_cp_up_hdr(
    ::structure::CpUpHdr* cp_up_hdr) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cp_up_hdr_);
  }
  cp_up_hdr_ = cp_up_hdr;
  if (cp_up_hdr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:srvEbm.SecurityConfigureReq.cp_up_hdr)
}
inline ::structure::CpUpHdr* SecurityConfigureReq::release_cp_up_hdr() {
  
  ::structure::CpUpHdr* temp = cp_up_hdr_;
  cp_up_hdr_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::structure::CpUpHdr* SecurityConfigureReq::unsafe_arena_release_cp_up_hdr() {
  // @@protoc_insertion_point(field_release:srvEbm.SecurityConfigureReq.cp_up_hdr)
  
  ::structure::CpUpHdr* temp = cp_up_hdr_;
  cp_up_hdr_ = nullptr;
  return temp;
}
inline ::structure::CpUpHdr* SecurityConfigureReq::_internal_mutable_cp_up_hdr() {
  
  if (cp_up_hdr_ == nullptr) {
    auto* p = CreateMaybeMessage<::structure::CpUpHdr>(GetArena());
    cp_up_hdr_ = p;
  }
  return cp_up_hdr_;
}
inline ::structure::CpUpHdr* SecurityConfigureReq::mutable_cp_up_hdr() {
  // @@protoc_insertion_point(field_mutable:srvEbm.SecurityConfigureReq.cp_up_hdr)
  return _internal_mutable_cp_up_hdr();
}
inline void SecurityConfigureReq::set_allocated_cp_up_hdr(::structure::CpUpHdr* cp_up_hdr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(cp_up_hdr_);
  }
  if (cp_up_hdr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cp_up_hdr)->GetArena();
    if (message_arena != submessage_arena) {
      cp_up_hdr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cp_up_hdr, submessage_arena);
    }
    
  } else {
    
  }
  cp_up_hdr_ = cp_up_hdr;
  // @@protoc_insertion_point(field_set_allocated:srvEbm.SecurityConfigureReq.cp_up_hdr)
}

// .structure.SecurityConfigure security_config = 30;
inline bool SecurityConfigureReq::_internal_has_security_config() const {
  return this != internal_default_instance() && security_config_ != nullptr;
}
inline bool SecurityConfigureReq::has_security_config() const {
  return _internal_has_security_config();
}
inline const ::structure::SecurityConfigure& SecurityConfigureReq::_internal_security_config() const {
  const ::structure::SecurityConfigure* p = security_config_;
  return p != nullptr ? *p : *reinterpret_cast<const ::structure::SecurityConfigure*>(
      &::structure::_SecurityConfigure_default_instance_);
}
inline const ::structure::SecurityConfigure& SecurityConfigureReq::security_config() const {
  // @@protoc_insertion_point(field_get:srvEbm.SecurityConfigureReq.security_config)
  return _internal_security_config();
}
inline void SecurityConfigureReq::unsafe_arena_set_allocated_security_config(
    ::structure::SecurityConfigure* security_config) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(security_config_);
  }
  security_config_ = security_config;
  if (security_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:srvEbm.SecurityConfigureReq.security_config)
}
inline ::structure::SecurityConfigure* SecurityConfigureReq::release_security_config() {
  
  ::structure::SecurityConfigure* temp = security_config_;
  security_config_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::structure::SecurityConfigure* SecurityConfigureReq::unsafe_arena_release_security_config() {
  // @@protoc_insertion_point(field_release:srvEbm.SecurityConfigureReq.security_config)
  
  ::structure::SecurityConfigure* temp = security_config_;
  security_config_ = nullptr;
  return temp;
}
inline ::structure::SecurityConfigure* SecurityConfigureReq::_internal_mutable_security_config() {
  
  if (security_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::structure::SecurityConfigure>(GetArena());
    security_config_ = p;
  }
  return security_config_;
}
inline ::structure::SecurityConfigure* SecurityConfigureReq::mutable_security_config() {
  // @@protoc_insertion_point(field_mutable:srvEbm.SecurityConfigureReq.security_config)
  return _internal_mutable_security_config();
}
inline void SecurityConfigureReq::set_allocated_security_config(::structure::SecurityConfigure* security_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(security_config_);
  }
  if (security_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(security_config)->GetArena();
    if (message_arena != submessage_arena) {
      security_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, security_config, submessage_arena);
    }
    
  } else {
    
  }
  security_config_ = security_config;
  // @@protoc_insertion_point(field_set_allocated:srvEbm.SecurityConfigureReq.security_config)
}

// -------------------------------------------------------------------

// CreateTunnelReq

// .mhdr.MsgHdr hdr = 10;
inline bool CreateTunnelReq::_internal_has_hdr() const {
  return this != internal_default_instance() && hdr_ != nullptr;
}
inline bool CreateTunnelReq::has_hdr() const {
  return _internal_has_hdr();
}
inline const ::mhdr::MsgHdr& CreateTunnelReq::_internal_hdr() const {
  const ::mhdr::MsgHdr* p = hdr_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mhdr::MsgHdr*>(
      &::mhdr::_MsgHdr_default_instance_);
}
inline const ::mhdr::MsgHdr& CreateTunnelReq::hdr() const {
  // @@protoc_insertion_point(field_get:srvEbm.CreateTunnelReq.hdr)
  return _internal_hdr();
}
inline void CreateTunnelReq::unsafe_arena_set_allocated_hdr(
    ::mhdr::MsgHdr* hdr) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hdr_);
  }
  hdr_ = hdr;
  if (hdr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:srvEbm.CreateTunnelReq.hdr)
}
inline ::mhdr::MsgHdr* CreateTunnelReq::release_hdr() {
  
  ::mhdr::MsgHdr* temp = hdr_;
  hdr_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mhdr::MsgHdr* CreateTunnelReq::unsafe_arena_release_hdr() {
  // @@protoc_insertion_point(field_release:srvEbm.CreateTunnelReq.hdr)
  
  ::mhdr::MsgHdr* temp = hdr_;
  hdr_ = nullptr;
  return temp;
}
inline ::mhdr::MsgHdr* CreateTunnelReq::_internal_mutable_hdr() {
  
  if (hdr_ == nullptr) {
    auto* p = CreateMaybeMessage<::mhdr::MsgHdr>(GetArena());
    hdr_ = p;
  }
  return hdr_;
}
inline ::mhdr::MsgHdr* CreateTunnelReq::mutable_hdr() {
  // @@protoc_insertion_point(field_mutable:srvEbm.CreateTunnelReq.hdr)
  return _internal_mutable_hdr();
}
inline void CreateTunnelReq::set_allocated_hdr(::mhdr::MsgHdr* hdr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(hdr_);
  }
  if (hdr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hdr)->GetArena();
    if (message_arena != submessage_arena) {
      hdr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hdr, submessage_arena);
    }
    
  } else {
    
  }
  hdr_ = hdr;
  // @@protoc_insertion_point(field_set_allocated:srvEbm.CreateTunnelReq.hdr)
}

// .structure.CpUpHdr cp_up_hdr = 20;
inline bool CreateTunnelReq::_internal_has_cp_up_hdr() const {
  return this != internal_default_instance() && cp_up_hdr_ != nullptr;
}
inline bool CreateTunnelReq::has_cp_up_hdr() const {
  return _internal_has_cp_up_hdr();
}
inline const ::structure::CpUpHdr& CreateTunnelReq::_internal_cp_up_hdr() const {
  const ::structure::CpUpHdr* p = cp_up_hdr_;
  return p != nullptr ? *p : *reinterpret_cast<const ::structure::CpUpHdr*>(
      &::structure::_CpUpHdr_default_instance_);
}
inline const ::structure::CpUpHdr& CreateTunnelReq::cp_up_hdr() const {
  // @@protoc_insertion_point(field_get:srvEbm.CreateTunnelReq.cp_up_hdr)
  return _internal_cp_up_hdr();
}
inline void CreateTunnelReq::unsafe_arena_set_allocated_cp_up_hdr(
    ::structure::CpUpHdr* cp_up_hdr) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cp_up_hdr_);
  }
  cp_up_hdr_ = cp_up_hdr;
  if (cp_up_hdr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:srvEbm.CreateTunnelReq.cp_up_hdr)
}
inline ::structure::CpUpHdr* CreateTunnelReq::release_cp_up_hdr() {
  
  ::structure::CpUpHdr* temp = cp_up_hdr_;
  cp_up_hdr_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::structure::CpUpHdr* CreateTunnelReq::unsafe_arena_release_cp_up_hdr() {
  // @@protoc_insertion_point(field_release:srvEbm.CreateTunnelReq.cp_up_hdr)
  
  ::structure::CpUpHdr* temp = cp_up_hdr_;
  cp_up_hdr_ = nullptr;
  return temp;
}
inline ::structure::CpUpHdr* CreateTunnelReq::_internal_mutable_cp_up_hdr() {
  
  if (cp_up_hdr_ == nullptr) {
    auto* p = CreateMaybeMessage<::structure::CpUpHdr>(GetArena());
    cp_up_hdr_ = p;
  }
  return cp_up_hdr_;
}
inline ::structure::CpUpHdr* CreateTunnelReq::mutable_cp_up_hdr() {
  // @@protoc_insertion_point(field_mutable:srvEbm.CreateTunnelReq.cp_up_hdr)
  return _internal_mutable_cp_up_hdr();
}
inline void CreateTunnelReq::set_allocated_cp_up_hdr(::structure::CpUpHdr* cp_up_hdr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(cp_up_hdr_);
  }
  if (cp_up_hdr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cp_up_hdr)->GetArena();
    if (message_arena != submessage_arena) {
      cp_up_hdr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cp_up_hdr, submessage_arena);
    }
    
  } else {
    
  }
  cp_up_hdr_ = cp_up_hdr;
  // @@protoc_insertion_point(field_set_allocated:srvEbm.CreateTunnelReq.cp_up_hdr)
}

// .structure.GtpTunInfo gtp_tnl_info = 30;
inline bool CreateTunnelReq::_internal_has_gtp_tnl_info() const {
  return this != internal_default_instance() && gtp_tnl_info_ != nullptr;
}
inline bool CreateTunnelReq::has_gtp_tnl_info() const {
  return _internal_has_gtp_tnl_info();
}
inline const ::structure::GtpTunInfo& CreateTunnelReq::_internal_gtp_tnl_info() const {
  const ::structure::GtpTunInfo* p = gtp_tnl_info_;
  return p != nullptr ? *p : *reinterpret_cast<const ::structure::GtpTunInfo*>(
      &::structure::_GtpTunInfo_default_instance_);
}
inline const ::structure::GtpTunInfo& CreateTunnelReq::gtp_tnl_info() const {
  // @@protoc_insertion_point(field_get:srvEbm.CreateTunnelReq.gtp_tnl_info)
  return _internal_gtp_tnl_info();
}
inline void CreateTunnelReq::unsafe_arena_set_allocated_gtp_tnl_info(
    ::structure::GtpTunInfo* gtp_tnl_info) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gtp_tnl_info_);
  }
  gtp_tnl_info_ = gtp_tnl_info;
  if (gtp_tnl_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:srvEbm.CreateTunnelReq.gtp_tnl_info)
}
inline ::structure::GtpTunInfo* CreateTunnelReq::release_gtp_tnl_info() {
  
  ::structure::GtpTunInfo* temp = gtp_tnl_info_;
  gtp_tnl_info_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::structure::GtpTunInfo* CreateTunnelReq::unsafe_arena_release_gtp_tnl_info() {
  // @@protoc_insertion_point(field_release:srvEbm.CreateTunnelReq.gtp_tnl_info)
  
  ::structure::GtpTunInfo* temp = gtp_tnl_info_;
  gtp_tnl_info_ = nullptr;
  return temp;
}
inline ::structure::GtpTunInfo* CreateTunnelReq::_internal_mutable_gtp_tnl_info() {
  
  if (gtp_tnl_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::structure::GtpTunInfo>(GetArena());
    gtp_tnl_info_ = p;
  }
  return gtp_tnl_info_;
}
inline ::structure::GtpTunInfo* CreateTunnelReq::mutable_gtp_tnl_info() {
  // @@protoc_insertion_point(field_mutable:srvEbm.CreateTunnelReq.gtp_tnl_info)
  return _internal_mutable_gtp_tnl_info();
}
inline void CreateTunnelReq::set_allocated_gtp_tnl_info(::structure::GtpTunInfo* gtp_tnl_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(gtp_tnl_info_);
  }
  if (gtp_tnl_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gtp_tnl_info)->GetArena();
    if (message_arena != submessage_arena) {
      gtp_tnl_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gtp_tnl_info, submessage_arena);
    }
    
  } else {
    
  }
  gtp_tnl_info_ = gtp_tnl_info;
  // @@protoc_insertion_point(field_set_allocated:srvEbm.CreateTunnelReq.gtp_tnl_info)
}

// -------------------------------------------------------------------

// ModifyTunnelReq

// .mhdr.MsgHdr hdr = 10;
inline bool ModifyTunnelReq::_internal_has_hdr() const {
  return this != internal_default_instance() && hdr_ != nullptr;
}
inline bool ModifyTunnelReq::has_hdr() const {
  return _internal_has_hdr();
}
inline const ::mhdr::MsgHdr& ModifyTunnelReq::_internal_hdr() const {
  const ::mhdr::MsgHdr* p = hdr_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mhdr::MsgHdr*>(
      &::mhdr::_MsgHdr_default_instance_);
}
inline const ::mhdr::MsgHdr& ModifyTunnelReq::hdr() const {
  // @@protoc_insertion_point(field_get:srvEbm.ModifyTunnelReq.hdr)
  return _internal_hdr();
}
inline void ModifyTunnelReq::unsafe_arena_set_allocated_hdr(
    ::mhdr::MsgHdr* hdr) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hdr_);
  }
  hdr_ = hdr;
  if (hdr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:srvEbm.ModifyTunnelReq.hdr)
}
inline ::mhdr::MsgHdr* ModifyTunnelReq::release_hdr() {
  
  ::mhdr::MsgHdr* temp = hdr_;
  hdr_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mhdr::MsgHdr* ModifyTunnelReq::unsafe_arena_release_hdr() {
  // @@protoc_insertion_point(field_release:srvEbm.ModifyTunnelReq.hdr)
  
  ::mhdr::MsgHdr* temp = hdr_;
  hdr_ = nullptr;
  return temp;
}
inline ::mhdr::MsgHdr* ModifyTunnelReq::_internal_mutable_hdr() {
  
  if (hdr_ == nullptr) {
    auto* p = CreateMaybeMessage<::mhdr::MsgHdr>(GetArena());
    hdr_ = p;
  }
  return hdr_;
}
inline ::mhdr::MsgHdr* ModifyTunnelReq::mutable_hdr() {
  // @@protoc_insertion_point(field_mutable:srvEbm.ModifyTunnelReq.hdr)
  return _internal_mutable_hdr();
}
inline void ModifyTunnelReq::set_allocated_hdr(::mhdr::MsgHdr* hdr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(hdr_);
  }
  if (hdr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hdr)->GetArena();
    if (message_arena != submessage_arena) {
      hdr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hdr, submessage_arena);
    }
    
  } else {
    
  }
  hdr_ = hdr;
  // @@protoc_insertion_point(field_set_allocated:srvEbm.ModifyTunnelReq.hdr)
}

// .structure.CpUpHdr cp_up_hdr = 20;
inline bool ModifyTunnelReq::_internal_has_cp_up_hdr() const {
  return this != internal_default_instance() && cp_up_hdr_ != nullptr;
}
inline bool ModifyTunnelReq::has_cp_up_hdr() const {
  return _internal_has_cp_up_hdr();
}
inline const ::structure::CpUpHdr& ModifyTunnelReq::_internal_cp_up_hdr() const {
  const ::structure::CpUpHdr* p = cp_up_hdr_;
  return p != nullptr ? *p : *reinterpret_cast<const ::structure::CpUpHdr*>(
      &::structure::_CpUpHdr_default_instance_);
}
inline const ::structure::CpUpHdr& ModifyTunnelReq::cp_up_hdr() const {
  // @@protoc_insertion_point(field_get:srvEbm.ModifyTunnelReq.cp_up_hdr)
  return _internal_cp_up_hdr();
}
inline void ModifyTunnelReq::unsafe_arena_set_allocated_cp_up_hdr(
    ::structure::CpUpHdr* cp_up_hdr) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cp_up_hdr_);
  }
  cp_up_hdr_ = cp_up_hdr;
  if (cp_up_hdr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:srvEbm.ModifyTunnelReq.cp_up_hdr)
}
inline ::structure::CpUpHdr* ModifyTunnelReq::release_cp_up_hdr() {
  
  ::structure::CpUpHdr* temp = cp_up_hdr_;
  cp_up_hdr_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::structure::CpUpHdr* ModifyTunnelReq::unsafe_arena_release_cp_up_hdr() {
  // @@protoc_insertion_point(field_release:srvEbm.ModifyTunnelReq.cp_up_hdr)
  
  ::structure::CpUpHdr* temp = cp_up_hdr_;
  cp_up_hdr_ = nullptr;
  return temp;
}
inline ::structure::CpUpHdr* ModifyTunnelReq::_internal_mutable_cp_up_hdr() {
  
  if (cp_up_hdr_ == nullptr) {
    auto* p = CreateMaybeMessage<::structure::CpUpHdr>(GetArena());
    cp_up_hdr_ = p;
  }
  return cp_up_hdr_;
}
inline ::structure::CpUpHdr* ModifyTunnelReq::mutable_cp_up_hdr() {
  // @@protoc_insertion_point(field_mutable:srvEbm.ModifyTunnelReq.cp_up_hdr)
  return _internal_mutable_cp_up_hdr();
}
inline void ModifyTunnelReq::set_allocated_cp_up_hdr(::structure::CpUpHdr* cp_up_hdr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(cp_up_hdr_);
  }
  if (cp_up_hdr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cp_up_hdr)->GetArena();
    if (message_arena != submessage_arena) {
      cp_up_hdr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cp_up_hdr, submessage_arena);
    }
    
  } else {
    
  }
  cp_up_hdr_ = cp_up_hdr;
  // @@protoc_insertion_point(field_set_allocated:srvEbm.ModifyTunnelReq.cp_up_hdr)
}

// .structure.GtpTunInfo gtp_tnl_info = 30;
inline bool ModifyTunnelReq::_internal_has_gtp_tnl_info() const {
  return this != internal_default_instance() && gtp_tnl_info_ != nullptr;
}
inline bool ModifyTunnelReq::has_gtp_tnl_info() const {
  return _internal_has_gtp_tnl_info();
}
inline const ::structure::GtpTunInfo& ModifyTunnelReq::_internal_gtp_tnl_info() const {
  const ::structure::GtpTunInfo* p = gtp_tnl_info_;
  return p != nullptr ? *p : *reinterpret_cast<const ::structure::GtpTunInfo*>(
      &::structure::_GtpTunInfo_default_instance_);
}
inline const ::structure::GtpTunInfo& ModifyTunnelReq::gtp_tnl_info() const {
  // @@protoc_insertion_point(field_get:srvEbm.ModifyTunnelReq.gtp_tnl_info)
  return _internal_gtp_tnl_info();
}
inline void ModifyTunnelReq::unsafe_arena_set_allocated_gtp_tnl_info(
    ::structure::GtpTunInfo* gtp_tnl_info) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gtp_tnl_info_);
  }
  gtp_tnl_info_ = gtp_tnl_info;
  if (gtp_tnl_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:srvEbm.ModifyTunnelReq.gtp_tnl_info)
}
inline ::structure::GtpTunInfo* ModifyTunnelReq::release_gtp_tnl_info() {
  
  ::structure::GtpTunInfo* temp = gtp_tnl_info_;
  gtp_tnl_info_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::structure::GtpTunInfo* ModifyTunnelReq::unsafe_arena_release_gtp_tnl_info() {
  // @@protoc_insertion_point(field_release:srvEbm.ModifyTunnelReq.gtp_tnl_info)
  
  ::structure::GtpTunInfo* temp = gtp_tnl_info_;
  gtp_tnl_info_ = nullptr;
  return temp;
}
inline ::structure::GtpTunInfo* ModifyTunnelReq::_internal_mutable_gtp_tnl_info() {
  
  if (gtp_tnl_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::structure::GtpTunInfo>(GetArena());
    gtp_tnl_info_ = p;
  }
  return gtp_tnl_info_;
}
inline ::structure::GtpTunInfo* ModifyTunnelReq::mutable_gtp_tnl_info() {
  // @@protoc_insertion_point(field_mutable:srvEbm.ModifyTunnelReq.gtp_tnl_info)
  return _internal_mutable_gtp_tnl_info();
}
inline void ModifyTunnelReq::set_allocated_gtp_tnl_info(::structure::GtpTunInfo* gtp_tnl_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(gtp_tnl_info_);
  }
  if (gtp_tnl_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gtp_tnl_info)->GetArena();
    if (message_arena != submessage_arena) {
      gtp_tnl_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gtp_tnl_info, submessage_arena);
    }
    
  } else {
    
  }
  gtp_tnl_info_ = gtp_tnl_info;
  // @@protoc_insertion_point(field_set_allocated:srvEbm.ModifyTunnelReq.gtp_tnl_info)
}

// -------------------------------------------------------------------

// DeleteTunnelReq

// .mhdr.MsgHdr hdr = 10;
inline bool DeleteTunnelReq::_internal_has_hdr() const {
  return this != internal_default_instance() && hdr_ != nullptr;
}
inline bool DeleteTunnelReq::has_hdr() const {
  return _internal_has_hdr();
}
inline const ::mhdr::MsgHdr& DeleteTunnelReq::_internal_hdr() const {
  const ::mhdr::MsgHdr* p = hdr_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mhdr::MsgHdr*>(
      &::mhdr::_MsgHdr_default_instance_);
}
inline const ::mhdr::MsgHdr& DeleteTunnelReq::hdr() const {
  // @@protoc_insertion_point(field_get:srvEbm.DeleteTunnelReq.hdr)
  return _internal_hdr();
}
inline void DeleteTunnelReq::unsafe_arena_set_allocated_hdr(
    ::mhdr::MsgHdr* hdr) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hdr_);
  }
  hdr_ = hdr;
  if (hdr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:srvEbm.DeleteTunnelReq.hdr)
}
inline ::mhdr::MsgHdr* DeleteTunnelReq::release_hdr() {
  
  ::mhdr::MsgHdr* temp = hdr_;
  hdr_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mhdr::MsgHdr* DeleteTunnelReq::unsafe_arena_release_hdr() {
  // @@protoc_insertion_point(field_release:srvEbm.DeleteTunnelReq.hdr)
  
  ::mhdr::MsgHdr* temp = hdr_;
  hdr_ = nullptr;
  return temp;
}
inline ::mhdr::MsgHdr* DeleteTunnelReq::_internal_mutable_hdr() {
  
  if (hdr_ == nullptr) {
    auto* p = CreateMaybeMessage<::mhdr::MsgHdr>(GetArena());
    hdr_ = p;
  }
  return hdr_;
}
inline ::mhdr::MsgHdr* DeleteTunnelReq::mutable_hdr() {
  // @@protoc_insertion_point(field_mutable:srvEbm.DeleteTunnelReq.hdr)
  return _internal_mutable_hdr();
}
inline void DeleteTunnelReq::set_allocated_hdr(::mhdr::MsgHdr* hdr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(hdr_);
  }
  if (hdr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hdr)->GetArena();
    if (message_arena != submessage_arena) {
      hdr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hdr, submessage_arena);
    }
    
  } else {
    
  }
  hdr_ = hdr;
  // @@protoc_insertion_point(field_set_allocated:srvEbm.DeleteTunnelReq.hdr)
}

// .structure.CpUpHdr cp_up_hdr = 20;
inline bool DeleteTunnelReq::_internal_has_cp_up_hdr() const {
  return this != internal_default_instance() && cp_up_hdr_ != nullptr;
}
inline bool DeleteTunnelReq::has_cp_up_hdr() const {
  return _internal_has_cp_up_hdr();
}
inline const ::structure::CpUpHdr& DeleteTunnelReq::_internal_cp_up_hdr() const {
  const ::structure::CpUpHdr* p = cp_up_hdr_;
  return p != nullptr ? *p : *reinterpret_cast<const ::structure::CpUpHdr*>(
      &::structure::_CpUpHdr_default_instance_);
}
inline const ::structure::CpUpHdr& DeleteTunnelReq::cp_up_hdr() const {
  // @@protoc_insertion_point(field_get:srvEbm.DeleteTunnelReq.cp_up_hdr)
  return _internal_cp_up_hdr();
}
inline void DeleteTunnelReq::unsafe_arena_set_allocated_cp_up_hdr(
    ::structure::CpUpHdr* cp_up_hdr) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cp_up_hdr_);
  }
  cp_up_hdr_ = cp_up_hdr;
  if (cp_up_hdr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:srvEbm.DeleteTunnelReq.cp_up_hdr)
}
inline ::structure::CpUpHdr* DeleteTunnelReq::release_cp_up_hdr() {
  
  ::structure::CpUpHdr* temp = cp_up_hdr_;
  cp_up_hdr_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::structure::CpUpHdr* DeleteTunnelReq::unsafe_arena_release_cp_up_hdr() {
  // @@protoc_insertion_point(field_release:srvEbm.DeleteTunnelReq.cp_up_hdr)
  
  ::structure::CpUpHdr* temp = cp_up_hdr_;
  cp_up_hdr_ = nullptr;
  return temp;
}
inline ::structure::CpUpHdr* DeleteTunnelReq::_internal_mutable_cp_up_hdr() {
  
  if (cp_up_hdr_ == nullptr) {
    auto* p = CreateMaybeMessage<::structure::CpUpHdr>(GetArena());
    cp_up_hdr_ = p;
  }
  return cp_up_hdr_;
}
inline ::structure::CpUpHdr* DeleteTunnelReq::mutable_cp_up_hdr() {
  // @@protoc_insertion_point(field_mutable:srvEbm.DeleteTunnelReq.cp_up_hdr)
  return _internal_mutable_cp_up_hdr();
}
inline void DeleteTunnelReq::set_allocated_cp_up_hdr(::structure::CpUpHdr* cp_up_hdr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(cp_up_hdr_);
  }
  if (cp_up_hdr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cp_up_hdr)->GetArena();
    if (message_arena != submessage_arena) {
      cp_up_hdr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cp_up_hdr, submessage_arena);
    }
    
  } else {
    
  }
  cp_up_hdr_ = cp_up_hdr;
  // @@protoc_insertion_point(field_set_allocated:srvEbm.DeleteTunnelReq.cp_up_hdr)
}

// -------------------------------------------------------------------

// AddRbConfigureReq

// .mhdr.MsgHdr hdr = 10;
inline bool AddRbConfigureReq::_internal_has_hdr() const {
  return this != internal_default_instance() && hdr_ != nullptr;
}
inline bool AddRbConfigureReq::has_hdr() const {
  return _internal_has_hdr();
}
inline const ::mhdr::MsgHdr& AddRbConfigureReq::_internal_hdr() const {
  const ::mhdr::MsgHdr* p = hdr_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mhdr::MsgHdr*>(
      &::mhdr::_MsgHdr_default_instance_);
}
inline const ::mhdr::MsgHdr& AddRbConfigureReq::hdr() const {
  // @@protoc_insertion_point(field_get:srvEbm.AddRbConfigureReq.hdr)
  return _internal_hdr();
}
inline void AddRbConfigureReq::unsafe_arena_set_allocated_hdr(
    ::mhdr::MsgHdr* hdr) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hdr_);
  }
  hdr_ = hdr;
  if (hdr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:srvEbm.AddRbConfigureReq.hdr)
}
inline ::mhdr::MsgHdr* AddRbConfigureReq::release_hdr() {
  
  ::mhdr::MsgHdr* temp = hdr_;
  hdr_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mhdr::MsgHdr* AddRbConfigureReq::unsafe_arena_release_hdr() {
  // @@protoc_insertion_point(field_release:srvEbm.AddRbConfigureReq.hdr)
  
  ::mhdr::MsgHdr* temp = hdr_;
  hdr_ = nullptr;
  return temp;
}
inline ::mhdr::MsgHdr* AddRbConfigureReq::_internal_mutable_hdr() {
  
  if (hdr_ == nullptr) {
    auto* p = CreateMaybeMessage<::mhdr::MsgHdr>(GetArena());
    hdr_ = p;
  }
  return hdr_;
}
inline ::mhdr::MsgHdr* AddRbConfigureReq::mutable_hdr() {
  // @@protoc_insertion_point(field_mutable:srvEbm.AddRbConfigureReq.hdr)
  return _internal_mutable_hdr();
}
inline void AddRbConfigureReq::set_allocated_hdr(::mhdr::MsgHdr* hdr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(hdr_);
  }
  if (hdr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hdr)->GetArena();
    if (message_arena != submessage_arena) {
      hdr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hdr, submessage_arena);
    }
    
  } else {
    
  }
  hdr_ = hdr;
  // @@protoc_insertion_point(field_set_allocated:srvEbm.AddRbConfigureReq.hdr)
}

// .structure.CpUpHdr cp_up_hdr = 20;
inline bool AddRbConfigureReq::_internal_has_cp_up_hdr() const {
  return this != internal_default_instance() && cp_up_hdr_ != nullptr;
}
inline bool AddRbConfigureReq::has_cp_up_hdr() const {
  return _internal_has_cp_up_hdr();
}
inline const ::structure::CpUpHdr& AddRbConfigureReq::_internal_cp_up_hdr() const {
  const ::structure::CpUpHdr* p = cp_up_hdr_;
  return p != nullptr ? *p : *reinterpret_cast<const ::structure::CpUpHdr*>(
      &::structure::_CpUpHdr_default_instance_);
}
inline const ::structure::CpUpHdr& AddRbConfigureReq::cp_up_hdr() const {
  // @@protoc_insertion_point(field_get:srvEbm.AddRbConfigureReq.cp_up_hdr)
  return _internal_cp_up_hdr();
}
inline void AddRbConfigureReq::unsafe_arena_set_allocated_cp_up_hdr(
    ::structure::CpUpHdr* cp_up_hdr) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cp_up_hdr_);
  }
  cp_up_hdr_ = cp_up_hdr;
  if (cp_up_hdr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:srvEbm.AddRbConfigureReq.cp_up_hdr)
}
inline ::structure::CpUpHdr* AddRbConfigureReq::release_cp_up_hdr() {
  
  ::structure::CpUpHdr* temp = cp_up_hdr_;
  cp_up_hdr_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::structure::CpUpHdr* AddRbConfigureReq::unsafe_arena_release_cp_up_hdr() {
  // @@protoc_insertion_point(field_release:srvEbm.AddRbConfigureReq.cp_up_hdr)
  
  ::structure::CpUpHdr* temp = cp_up_hdr_;
  cp_up_hdr_ = nullptr;
  return temp;
}
inline ::structure::CpUpHdr* AddRbConfigureReq::_internal_mutable_cp_up_hdr() {
  
  if (cp_up_hdr_ == nullptr) {
    auto* p = CreateMaybeMessage<::structure::CpUpHdr>(GetArena());
    cp_up_hdr_ = p;
  }
  return cp_up_hdr_;
}
inline ::structure::CpUpHdr* AddRbConfigureReq::mutable_cp_up_hdr() {
  // @@protoc_insertion_point(field_mutable:srvEbm.AddRbConfigureReq.cp_up_hdr)
  return _internal_mutable_cp_up_hdr();
}
inline void AddRbConfigureReq::set_allocated_cp_up_hdr(::structure::CpUpHdr* cp_up_hdr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(cp_up_hdr_);
  }
  if (cp_up_hdr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cp_up_hdr)->GetArena();
    if (message_arena != submessage_arena) {
      cp_up_hdr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cp_up_hdr, submessage_arena);
    }
    
  } else {
    
  }
  cp_up_hdr_ = cp_up_hdr;
  // @@protoc_insertion_point(field_set_allocated:srvEbm.AddRbConfigureReq.cp_up_hdr)
}

// .structure.PDCPConfigure pdcp_configure = 30;
inline bool AddRbConfigureReq::_internal_has_pdcp_configure() const {
  return this != internal_default_instance() && pdcp_configure_ != nullptr;
}
inline bool AddRbConfigureReq::has_pdcp_configure() const {
  return _internal_has_pdcp_configure();
}
inline const ::structure::PDCPConfigure& AddRbConfigureReq::_internal_pdcp_configure() const {
  const ::structure::PDCPConfigure* p = pdcp_configure_;
  return p != nullptr ? *p : *reinterpret_cast<const ::structure::PDCPConfigure*>(
      &::structure::_PDCPConfigure_default_instance_);
}
inline const ::structure::PDCPConfigure& AddRbConfigureReq::pdcp_configure() const {
  // @@protoc_insertion_point(field_get:srvEbm.AddRbConfigureReq.pdcp_configure)
  return _internal_pdcp_configure();
}
inline void AddRbConfigureReq::unsafe_arena_set_allocated_pdcp_configure(
    ::structure::PDCPConfigure* pdcp_configure) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pdcp_configure_);
  }
  pdcp_configure_ = pdcp_configure;
  if (pdcp_configure) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:srvEbm.AddRbConfigureReq.pdcp_configure)
}
inline ::structure::PDCPConfigure* AddRbConfigureReq::release_pdcp_configure() {
  
  ::structure::PDCPConfigure* temp = pdcp_configure_;
  pdcp_configure_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::structure::PDCPConfigure* AddRbConfigureReq::unsafe_arena_release_pdcp_configure() {
  // @@protoc_insertion_point(field_release:srvEbm.AddRbConfigureReq.pdcp_configure)
  
  ::structure::PDCPConfigure* temp = pdcp_configure_;
  pdcp_configure_ = nullptr;
  return temp;
}
inline ::structure::PDCPConfigure* AddRbConfigureReq::_internal_mutable_pdcp_configure() {
  
  if (pdcp_configure_ == nullptr) {
    auto* p = CreateMaybeMessage<::structure::PDCPConfigure>(GetArena());
    pdcp_configure_ = p;
  }
  return pdcp_configure_;
}
inline ::structure::PDCPConfigure* AddRbConfigureReq::mutable_pdcp_configure() {
  // @@protoc_insertion_point(field_mutable:srvEbm.AddRbConfigureReq.pdcp_configure)
  return _internal_mutable_pdcp_configure();
}
inline void AddRbConfigureReq::set_allocated_pdcp_configure(::structure::PDCPConfigure* pdcp_configure) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pdcp_configure_);
  }
  if (pdcp_configure) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pdcp_configure)->GetArena();
    if (message_arena != submessage_arena) {
      pdcp_configure = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pdcp_configure, submessage_arena);
    }
    
  } else {
    
  }
  pdcp_configure_ = pdcp_configure;
  // @@protoc_insertion_point(field_set_allocated:srvEbm.AddRbConfigureReq.pdcp_configure)
}

// -------------------------------------------------------------------

// ReqReply

// .mhdr.MsgHdr hdr = 10;
inline bool ReqReply::_internal_has_hdr() const {
  return this != internal_default_instance() && hdr_ != nullptr;
}
inline bool ReqReply::has_hdr() const {
  return _internal_has_hdr();
}
inline const ::mhdr::MsgHdr& ReqReply::_internal_hdr() const {
  const ::mhdr::MsgHdr* p = hdr_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mhdr::MsgHdr*>(
      &::mhdr::_MsgHdr_default_instance_);
}
inline const ::mhdr::MsgHdr& ReqReply::hdr() const {
  // @@protoc_insertion_point(field_get:srvEbm.ReqReply.hdr)
  return _internal_hdr();
}
inline void ReqReply::unsafe_arena_set_allocated_hdr(
    ::mhdr::MsgHdr* hdr) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hdr_);
  }
  hdr_ = hdr;
  if (hdr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:srvEbm.ReqReply.hdr)
}
inline ::mhdr::MsgHdr* ReqReply::release_hdr() {
  
  ::mhdr::MsgHdr* temp = hdr_;
  hdr_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mhdr::MsgHdr* ReqReply::unsafe_arena_release_hdr() {
  // @@protoc_insertion_point(field_release:srvEbm.ReqReply.hdr)
  
  ::mhdr::MsgHdr* temp = hdr_;
  hdr_ = nullptr;
  return temp;
}
inline ::mhdr::MsgHdr* ReqReply::_internal_mutable_hdr() {
  
  if (hdr_ == nullptr) {
    auto* p = CreateMaybeMessage<::mhdr::MsgHdr>(GetArena());
    hdr_ = p;
  }
  return hdr_;
}
inline ::mhdr::MsgHdr* ReqReply::mutable_hdr() {
  // @@protoc_insertion_point(field_mutable:srvEbm.ReqReply.hdr)
  return _internal_mutable_hdr();
}
inline void ReqReply::set_allocated_hdr(::mhdr::MsgHdr* hdr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(hdr_);
  }
  if (hdr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hdr)->GetArena();
    if (message_arena != submessage_arena) {
      hdr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hdr, submessage_arena);
    }
    
  } else {
    
  }
  hdr_ = hdr;
  // @@protoc_insertion_point(field_set_allocated:srvEbm.ReqReply.hdr)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace srvEbm

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::srvEbm::method> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::srvEbm::method>() {
  return ::srvEbm::method_descriptor();
}
template <> struct is_proto_enum< ::srvEbm::version> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::srvEbm::version>() {
  return ::srvEbm::version_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_srvEbm_2eproto
