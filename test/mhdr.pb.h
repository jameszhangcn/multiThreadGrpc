// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mhdr.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_mhdr_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_mhdr_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3013000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3013000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_mhdr_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_mhdr_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[4]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_mhdr_2eproto;
namespace mhdr {
class Location;
class LocationDefaultTypeInternal;
extern LocationDefaultTypeInternal _Location_default_instance_;
class MsgHdr;
class MsgHdrDefaultTypeInternal;
extern MsgHdrDefaultTypeInternal _MsgHdr_default_instance_;
class RID;
class RIDDefaultTypeInternal;
extern RIDDefaultTypeInternal _RID_default_instance_;
class RouteInfo;
class RouteInfoDefaultTypeInternal;
extern RouteInfoDefaultTypeInternal _RouteInfo_default_instance_;
}  // namespace mhdr
PROTOBUF_NAMESPACE_OPEN
template<> ::mhdr::Location* Arena::CreateMaybeMessage<::mhdr::Location>(Arena*);
template<> ::mhdr::MsgHdr* Arena::CreateMaybeMessage<::mhdr::MsgHdr>(Arena*);
template<> ::mhdr::RID* Arena::CreateMaybeMessage<::mhdr::RID>(Arena*);
template<> ::mhdr::RouteInfo* Arena::CreateMaybeMessage<::mhdr::RouteInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace mhdr {

enum Transport : int {
  TCP = 0,
  TLS = 1,
  Transport_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Transport_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Transport_IsValid(int value);
constexpr Transport Transport_MIN = TCP;
constexpr Transport Transport_MAX = TLS;
constexpr int Transport_ARRAYSIZE = Transport_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Transport_descriptor();
template<typename T>
inline const std::string& Transport_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Transport>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Transport_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Transport_descriptor(), enum_t_value);
}
inline bool Transport_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Transport* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Transport>(
    Transport_descriptor(), name, value);
}
// ===================================================================

class RID PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mhdr.RID) */ {
 public:
  inline RID() : RID(nullptr) {}
  virtual ~RID();

  RID(const RID& from);
  RID(RID&& from) noexcept
    : RID() {
    *this = ::std::move(from);
  }

  inline RID& operator=(const RID& from) {
    CopyFrom(from);
    return *this;
  }
  inline RID& operator=(RID&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RID& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RID* internal_default_instance() {
    return reinterpret_cast<const RID*>(
               &_RID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RID& a, RID& b) {
    a.Swap(&b);
  }
  inline void Swap(RID* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RID* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RID* New() const final {
    return CreateMaybeMessage<RID>(nullptr);
  }

  RID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RID>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RID& from);
  void MergeFrom(const RID& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RID* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mhdr.RID";
  }
  protected:
  explicit RID(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mhdr_2eproto);
    return ::descriptor_table_mhdr_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSnFieldNumber = 10,
    kCidFieldNumber = 20,
  };
  // string sn = 10;
  void clear_sn();
  const std::string& sn() const;
  void set_sn(const std::string& value);
  void set_sn(std::string&& value);
  void set_sn(const char* value);
  void set_sn(const char* value, size_t size);
  std::string* mutable_sn();
  std::string* release_sn();
  void set_allocated_sn(std::string* sn);
  private:
  const std::string& _internal_sn() const;
  void _internal_set_sn(const std::string& value);
  std::string* _internal_mutable_sn();
  public:

  // string cid = 20;
  void clear_cid();
  const std::string& cid() const;
  void set_cid(const std::string& value);
  void set_cid(std::string&& value);
  void set_cid(const char* value);
  void set_cid(const char* value, size_t size);
  std::string* mutable_cid();
  std::string* release_cid();
  void set_allocated_cid(std::string* cid);
  private:
  const std::string& _internal_cid() const;
  void _internal_set_cid(const std::string& value);
  std::string* _internal_mutable_cid();
  public:

  // @@protoc_insertion_point(class_scope:mhdr.RID)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sn_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mhdr_2eproto;
};
// -------------------------------------------------------------------

class Location PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mhdr.Location) */ {
 public:
  inline Location() : Location(nullptr) {}
  virtual ~Location();

  Location(const Location& from);
  Location(Location&& from) noexcept
    : Location() {
    *this = ::std::move(from);
  }

  inline Location& operator=(const Location& from) {
    CopyFrom(from);
    return *this;
  }
  inline Location& operator=(Location&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Location& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Location* internal_default_instance() {
    return reinterpret_cast<const Location*>(
               &_Location_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Location& a, Location& b) {
    a.Swap(&b);
  }
  inline void Swap(Location* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Location* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Location* New() const final {
    return CreateMaybeMessage<Location>(nullptr);
  }

  Location* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Location>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Location& from);
  void MergeFrom(const Location& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Location* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mhdr.Location";
  }
  protected:
  explicit Location(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mhdr_2eproto);
    return ::descriptor_table_mhdr_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 20,
    kTrportFieldNumber = 10,
    kPortFieldNumber = 30,
  };
  // string address = 20;
  void clear_address();
  const std::string& address() const;
  void set_address(const std::string& value);
  void set_address(std::string&& value);
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  std::string* mutable_address();
  std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // .mhdr.Transport trport = 10;
  void clear_trport();
  ::mhdr::Transport trport() const;
  void set_trport(::mhdr::Transport value);
  private:
  ::mhdr::Transport _internal_trport() const;
  void _internal_set_trport(::mhdr::Transport value);
  public:

  // fixed32 port = 30;
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::uint32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_port() const;
  void _internal_set_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:mhdr.Location)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  int trport_;
  ::PROTOBUF_NAMESPACE_ID::uint32 port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mhdr_2eproto;
};
// -------------------------------------------------------------------

class RouteInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mhdr.RouteInfo) */ {
 public:
  inline RouteInfo() : RouteInfo(nullptr) {}
  virtual ~RouteInfo();

  RouteInfo(const RouteInfo& from);
  RouteInfo(RouteInfo&& from) noexcept
    : RouteInfo() {
    *this = ::std::move(from);
  }

  inline RouteInfo& operator=(const RouteInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteInfo& operator=(RouteInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RouteInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RouteInfo* internal_default_instance() {
    return reinterpret_cast<const RouteInfo*>(
               &_RouteInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RouteInfo& a, RouteInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RouteInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RouteInfo* New() const final {
    return CreateMaybeMessage<RouteInfo>(nullptr);
  }

  RouteInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RouteInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RouteInfo& from);
  void MergeFrom(const RouteInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouteInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mhdr.RouteInfo";
  }
  protected:
  explicit RouteInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mhdr_2eproto);
    return ::descriptor_table_mhdr_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocFieldNumber = 20,
    kRidFieldNumber = 10,
  };
  // string loc = 20;
  void clear_loc();
  const std::string& loc() const;
  void set_loc(const std::string& value);
  void set_loc(std::string&& value);
  void set_loc(const char* value);
  void set_loc(const char* value, size_t size);
  std::string* mutable_loc();
  std::string* release_loc();
  void set_allocated_loc(std::string* loc);
  private:
  const std::string& _internal_loc() const;
  void _internal_set_loc(const std::string& value);
  std::string* _internal_mutable_loc();
  public:

  // .mhdr.RID rid = 10;
  bool has_rid() const;
  private:
  bool _internal_has_rid() const;
  public:
  void clear_rid();
  const ::mhdr::RID& rid() const;
  ::mhdr::RID* release_rid();
  ::mhdr::RID* mutable_rid();
  void set_allocated_rid(::mhdr::RID* rid);
  private:
  const ::mhdr::RID& _internal_rid() const;
  ::mhdr::RID* _internal_mutable_rid();
  public:
  void unsafe_arena_set_allocated_rid(
      ::mhdr::RID* rid);
  ::mhdr::RID* unsafe_arena_release_rid();

  // @@protoc_insertion_point(class_scope:mhdr.RouteInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr loc_;
  ::mhdr::RID* rid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mhdr_2eproto;
};
// -------------------------------------------------------------------

class MsgHdr PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mhdr.MsgHdr) */ {
 public:
  inline MsgHdr() : MsgHdr(nullptr) {}
  virtual ~MsgHdr();

  MsgHdr(const MsgHdr& from);
  MsgHdr(MsgHdr&& from) noexcept
    : MsgHdr() {
    *this = ::std::move(from);
  }

  inline MsgHdr& operator=(const MsgHdr& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgHdr& operator=(MsgHdr&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MsgHdr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgHdr* internal_default_instance() {
    return reinterpret_cast<const MsgHdr*>(
               &_MsgHdr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MsgHdr& a, MsgHdr& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgHdr* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgHdr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MsgHdr* New() const final {
    return CreateMaybeMessage<MsgHdr>(nullptr);
  }

  MsgHdr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MsgHdr>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MsgHdr& from);
  void MergeFrom(const MsgHdr& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgHdr* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mhdr.MsgHdr";
  }
  protected:
  explicit MsgHdr(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mhdr_2eproto);
    return ::descriptor_table_mhdr_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAltToLocsFieldNumber = 90,
    kRoutesFieldNumber = 140,
    kViasFieldNumber = 150,
    kMethodNameFieldNumber = 50,
    kSidFieldNumber = 120,
    kTraceIDFieldNumber = 130,
    kToRIDFieldNumber = 60,
    kFromRIDFieldNumber = 70,
    kToLocFieldNumber = 80,
    kFromLocFieldNumber = 100,
    kVersionFieldNumber = 10,
    kIsReqFieldNumber = 20,
    kTransIDFieldNumber = 110,
    kRspCodeFieldNumber = 30,
    kMethodFieldNumber = 40,
  };
  // repeated .mhdr.Location altToLocs = 90;
  int alttolocs_size() const;
  private:
  int _internal_alttolocs_size() const;
  public:
  void clear_alttolocs();
  ::mhdr::Location* mutable_alttolocs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mhdr::Location >*
      mutable_alttolocs();
  private:
  const ::mhdr::Location& _internal_alttolocs(int index) const;
  ::mhdr::Location* _internal_add_alttolocs();
  public:
  const ::mhdr::Location& alttolocs(int index) const;
  ::mhdr::Location* add_alttolocs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mhdr::Location >&
      alttolocs() const;

  // repeated .mhdr.RouteInfo routes = 140;
  int routes_size() const;
  private:
  int _internal_routes_size() const;
  public:
  void clear_routes();
  ::mhdr::RouteInfo* mutable_routes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mhdr::RouteInfo >*
      mutable_routes();
  private:
  const ::mhdr::RouteInfo& _internal_routes(int index) const;
  ::mhdr::RouteInfo* _internal_add_routes();
  public:
  const ::mhdr::RouteInfo& routes(int index) const;
  ::mhdr::RouteInfo* add_routes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mhdr::RouteInfo >&
      routes() const;

  // repeated .mhdr.RouteInfo vias = 150;
  int vias_size() const;
  private:
  int _internal_vias_size() const;
  public:
  void clear_vias();
  ::mhdr::RouteInfo* mutable_vias(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mhdr::RouteInfo >*
      mutable_vias();
  private:
  const ::mhdr::RouteInfo& _internal_vias(int index) const;
  ::mhdr::RouteInfo* _internal_add_vias();
  public:
  const ::mhdr::RouteInfo& vias(int index) const;
  ::mhdr::RouteInfo* add_vias();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mhdr::RouteInfo >&
      vias() const;

  // string methodName = 50;
  void clear_methodname();
  const std::string& methodname() const;
  void set_methodname(const std::string& value);
  void set_methodname(std::string&& value);
  void set_methodname(const char* value);
  void set_methodname(const char* value, size_t size);
  std::string* mutable_methodname();
  std::string* release_methodname();
  void set_allocated_methodname(std::string* methodname);
  private:
  const std::string& _internal_methodname() const;
  void _internal_set_methodname(const std::string& value);
  std::string* _internal_mutable_methodname();
  public:

  // string sid = 120;
  void clear_sid();
  const std::string& sid() const;
  void set_sid(const std::string& value);
  void set_sid(std::string&& value);
  void set_sid(const char* value);
  void set_sid(const char* value, size_t size);
  std::string* mutable_sid();
  std::string* release_sid();
  void set_allocated_sid(std::string* sid);
  private:
  const std::string& _internal_sid() const;
  void _internal_set_sid(const std::string& value);
  std::string* _internal_mutable_sid();
  public:

  // string traceID = 130;
  void clear_traceid();
  const std::string& traceid() const;
  void set_traceid(const std::string& value);
  void set_traceid(std::string&& value);
  void set_traceid(const char* value);
  void set_traceid(const char* value, size_t size);
  std::string* mutable_traceid();
  std::string* release_traceid();
  void set_allocated_traceid(std::string* traceid);
  private:
  const std::string& _internal_traceid() const;
  void _internal_set_traceid(const std::string& value);
  std::string* _internal_mutable_traceid();
  public:

  // .mhdr.RID toRID = 60;
  bool has_torid() const;
  private:
  bool _internal_has_torid() const;
  public:
  void clear_torid();
  const ::mhdr::RID& torid() const;
  ::mhdr::RID* release_torid();
  ::mhdr::RID* mutable_torid();
  void set_allocated_torid(::mhdr::RID* torid);
  private:
  const ::mhdr::RID& _internal_torid() const;
  ::mhdr::RID* _internal_mutable_torid();
  public:
  void unsafe_arena_set_allocated_torid(
      ::mhdr::RID* torid);
  ::mhdr::RID* unsafe_arena_release_torid();

  // .mhdr.RID fromRID = 70;
  bool has_fromrid() const;
  private:
  bool _internal_has_fromrid() const;
  public:
  void clear_fromrid();
  const ::mhdr::RID& fromrid() const;
  ::mhdr::RID* release_fromrid();
  ::mhdr::RID* mutable_fromrid();
  void set_allocated_fromrid(::mhdr::RID* fromrid);
  private:
  const ::mhdr::RID& _internal_fromrid() const;
  ::mhdr::RID* _internal_mutable_fromrid();
  public:
  void unsafe_arena_set_allocated_fromrid(
      ::mhdr::RID* fromrid);
  ::mhdr::RID* unsafe_arena_release_fromrid();

  // .mhdr.Location toLoc = 80;
  bool has_toloc() const;
  private:
  bool _internal_has_toloc() const;
  public:
  void clear_toloc();
  const ::mhdr::Location& toloc() const;
  ::mhdr::Location* release_toloc();
  ::mhdr::Location* mutable_toloc();
  void set_allocated_toloc(::mhdr::Location* toloc);
  private:
  const ::mhdr::Location& _internal_toloc() const;
  ::mhdr::Location* _internal_mutable_toloc();
  public:
  void unsafe_arena_set_allocated_toloc(
      ::mhdr::Location* toloc);
  ::mhdr::Location* unsafe_arena_release_toloc();

  // .mhdr.Location fromLoc = 100;
  bool has_fromloc() const;
  private:
  bool _internal_has_fromloc() const;
  public:
  void clear_fromloc();
  const ::mhdr::Location& fromloc() const;
  ::mhdr::Location* release_fromloc();
  ::mhdr::Location* mutable_fromloc();
  void set_allocated_fromloc(::mhdr::Location* fromloc);
  private:
  const ::mhdr::Location& _internal_fromloc() const;
  ::mhdr::Location* _internal_mutable_fromloc();
  public:
  void unsafe_arena_set_allocated_fromloc(
      ::mhdr::Location* fromloc);
  ::mhdr::Location* unsafe_arena_release_fromloc();

  // uint32 version = 10;
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::uint32 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // bool isReq = 20;
  void clear_isreq();
  bool isreq() const;
  void set_isreq(bool value);
  private:
  bool _internal_isreq() const;
  void _internal_set_isreq(bool value);
  public:

  // uint32 transID = 110;
  void clear_transid();
  ::PROTOBUF_NAMESPACE_ID::uint32 transid() const;
  void set_transid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_transid() const;
  void _internal_set_transid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 rspCode = 30;
  void clear_rspcode();
  ::PROTOBUF_NAMESPACE_ID::uint32 rspcode() const;
  void set_rspcode(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_rspcode() const;
  void _internal_set_rspcode(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // int32 method = 40;
  void clear_method();
  ::PROTOBUF_NAMESPACE_ID::int32 method() const;
  void set_method(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_method() const;
  void _internal_set_method(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:mhdr.MsgHdr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mhdr::Location > alttolocs_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mhdr::RouteInfo > routes_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mhdr::RouteInfo > vias_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr methodname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr traceid_;
  ::mhdr::RID* torid_;
  ::mhdr::RID* fromrid_;
  ::mhdr::Location* toloc_;
  ::mhdr::Location* fromloc_;
  ::PROTOBUF_NAMESPACE_ID::uint32 version_;
  bool isreq_;
  ::PROTOBUF_NAMESPACE_ID::uint32 transid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 rspcode_;
  ::PROTOBUF_NAMESPACE_ID::int32 method_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mhdr_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RID

// string sn = 10;
inline void RID::clear_sn() {
  sn_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& RID::sn() const {
  // @@protoc_insertion_point(field_get:mhdr.RID.sn)
  return _internal_sn();
}
inline void RID::set_sn(const std::string& value) {
  _internal_set_sn(value);
  // @@protoc_insertion_point(field_set:mhdr.RID.sn)
}
inline std::string* RID::mutable_sn() {
  // @@protoc_insertion_point(field_mutable:mhdr.RID.sn)
  return _internal_mutable_sn();
}
inline const std::string& RID::_internal_sn() const {
  return sn_.Get();
}
inline void RID::_internal_set_sn(const std::string& value) {
  
  sn_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RID::set_sn(std::string&& value) {
  
  sn_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mhdr.RID.sn)
}
inline void RID::set_sn(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  sn_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mhdr.RID.sn)
}
inline void RID::set_sn(const char* value,
    size_t size) {
  
  sn_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mhdr.RID.sn)
}
inline std::string* RID::_internal_mutable_sn() {
  
  return sn_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RID::release_sn() {
  // @@protoc_insertion_point(field_release:mhdr.RID.sn)
  return sn_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RID::set_allocated_sn(std::string* sn) {
  if (sn != nullptr) {
    
  } else {
    
  }
  sn_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sn,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mhdr.RID.sn)
}

// string cid = 20;
inline void RID::clear_cid() {
  cid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& RID::cid() const {
  // @@protoc_insertion_point(field_get:mhdr.RID.cid)
  return _internal_cid();
}
inline void RID::set_cid(const std::string& value) {
  _internal_set_cid(value);
  // @@protoc_insertion_point(field_set:mhdr.RID.cid)
}
inline std::string* RID::mutable_cid() {
  // @@protoc_insertion_point(field_mutable:mhdr.RID.cid)
  return _internal_mutable_cid();
}
inline const std::string& RID::_internal_cid() const {
  return cid_.Get();
}
inline void RID::_internal_set_cid(const std::string& value) {
  
  cid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RID::set_cid(std::string&& value) {
  
  cid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mhdr.RID.cid)
}
inline void RID::set_cid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  cid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mhdr.RID.cid)
}
inline void RID::set_cid(const char* value,
    size_t size) {
  
  cid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mhdr.RID.cid)
}
inline std::string* RID::_internal_mutable_cid() {
  
  return cid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RID::release_cid() {
  // @@protoc_insertion_point(field_release:mhdr.RID.cid)
  return cid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RID::set_allocated_cid(std::string* cid) {
  if (cid != nullptr) {
    
  } else {
    
  }
  cid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mhdr.RID.cid)
}

// -------------------------------------------------------------------

// Location

// .mhdr.Transport trport = 10;
inline void Location::clear_trport() {
  trport_ = 0;
}
inline ::mhdr::Transport Location::_internal_trport() const {
  return static_cast< ::mhdr::Transport >(trport_);
}
inline ::mhdr::Transport Location::trport() const {
  // @@protoc_insertion_point(field_get:mhdr.Location.trport)
  return _internal_trport();
}
inline void Location::_internal_set_trport(::mhdr::Transport value) {
  
  trport_ = value;
}
inline void Location::set_trport(::mhdr::Transport value) {
  _internal_set_trport(value);
  // @@protoc_insertion_point(field_set:mhdr.Location.trport)
}

// string address = 20;
inline void Location::clear_address() {
  address_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Location::address() const {
  // @@protoc_insertion_point(field_get:mhdr.Location.address)
  return _internal_address();
}
inline void Location::set_address(const std::string& value) {
  _internal_set_address(value);
  // @@protoc_insertion_point(field_set:mhdr.Location.address)
}
inline std::string* Location::mutable_address() {
  // @@protoc_insertion_point(field_mutable:mhdr.Location.address)
  return _internal_mutable_address();
}
inline const std::string& Location::_internal_address() const {
  return address_.Get();
}
inline void Location::_internal_set_address(const std::string& value) {
  
  address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Location::set_address(std::string&& value) {
  
  address_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mhdr.Location.address)
}
inline void Location::set_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mhdr.Location.address)
}
inline void Location::set_address(const char* value,
    size_t size) {
  
  address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mhdr.Location.address)
}
inline std::string* Location::_internal_mutable_address() {
  
  return address_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Location::release_address() {
  // @@protoc_insertion_point(field_release:mhdr.Location.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Location::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mhdr.Location.address)
}

// fixed32 port = 30;
inline void Location::clear_port() {
  port_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Location::_internal_port() const {
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Location::port() const {
  // @@protoc_insertion_point(field_get:mhdr.Location.port)
  return _internal_port();
}
inline void Location::_internal_set_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  port_ = value;
}
inline void Location::set_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:mhdr.Location.port)
}

// -------------------------------------------------------------------

// RouteInfo

// .mhdr.RID rid = 10;
inline bool RouteInfo::_internal_has_rid() const {
  return this != internal_default_instance() && rid_ != nullptr;
}
inline bool RouteInfo::has_rid() const {
  return _internal_has_rid();
}
inline void RouteInfo::clear_rid() {
  if (GetArena() == nullptr && rid_ != nullptr) {
    delete rid_;
  }
  rid_ = nullptr;
}
inline const ::mhdr::RID& RouteInfo::_internal_rid() const {
  const ::mhdr::RID* p = rid_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mhdr::RID*>(
      &::mhdr::_RID_default_instance_);
}
inline const ::mhdr::RID& RouteInfo::rid() const {
  // @@protoc_insertion_point(field_get:mhdr.RouteInfo.rid)
  return _internal_rid();
}
inline void RouteInfo::unsafe_arena_set_allocated_rid(
    ::mhdr::RID* rid) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rid_);
  }
  rid_ = rid;
  if (rid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mhdr.RouteInfo.rid)
}
inline ::mhdr::RID* RouteInfo::release_rid() {
  
  ::mhdr::RID* temp = rid_;
  rid_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mhdr::RID* RouteInfo::unsafe_arena_release_rid() {
  // @@protoc_insertion_point(field_release:mhdr.RouteInfo.rid)
  
  ::mhdr::RID* temp = rid_;
  rid_ = nullptr;
  return temp;
}
inline ::mhdr::RID* RouteInfo::_internal_mutable_rid() {
  
  if (rid_ == nullptr) {
    auto* p = CreateMaybeMessage<::mhdr::RID>(GetArena());
    rid_ = p;
  }
  return rid_;
}
inline ::mhdr::RID* RouteInfo::mutable_rid() {
  // @@protoc_insertion_point(field_mutable:mhdr.RouteInfo.rid)
  return _internal_mutable_rid();
}
inline void RouteInfo::set_allocated_rid(::mhdr::RID* rid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete rid_;
  }
  if (rid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(rid);
    if (message_arena != submessage_arena) {
      rid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rid, submessage_arena);
    }
    
  } else {
    
  }
  rid_ = rid;
  // @@protoc_insertion_point(field_set_allocated:mhdr.RouteInfo.rid)
}

// string loc = 20;
inline void RouteInfo::clear_loc() {
  loc_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& RouteInfo::loc() const {
  // @@protoc_insertion_point(field_get:mhdr.RouteInfo.loc)
  return _internal_loc();
}
inline void RouteInfo::set_loc(const std::string& value) {
  _internal_set_loc(value);
  // @@protoc_insertion_point(field_set:mhdr.RouteInfo.loc)
}
inline std::string* RouteInfo::mutable_loc() {
  // @@protoc_insertion_point(field_mutable:mhdr.RouteInfo.loc)
  return _internal_mutable_loc();
}
inline const std::string& RouteInfo::_internal_loc() const {
  return loc_.Get();
}
inline void RouteInfo::_internal_set_loc(const std::string& value) {
  
  loc_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RouteInfo::set_loc(std::string&& value) {
  
  loc_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mhdr.RouteInfo.loc)
}
inline void RouteInfo::set_loc(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  loc_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mhdr.RouteInfo.loc)
}
inline void RouteInfo::set_loc(const char* value,
    size_t size) {
  
  loc_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mhdr.RouteInfo.loc)
}
inline std::string* RouteInfo::_internal_mutable_loc() {
  
  return loc_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RouteInfo::release_loc() {
  // @@protoc_insertion_point(field_release:mhdr.RouteInfo.loc)
  return loc_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RouteInfo::set_allocated_loc(std::string* loc) {
  if (loc != nullptr) {
    
  } else {
    
  }
  loc_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), loc,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mhdr.RouteInfo.loc)
}

// -------------------------------------------------------------------

// MsgHdr

// uint32 version = 10;
inline void MsgHdr::clear_version() {
  version_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MsgHdr::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MsgHdr::version() const {
  // @@protoc_insertion_point(field_get:mhdr.MsgHdr.version)
  return _internal_version();
}
inline void MsgHdr::_internal_set_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  version_ = value;
}
inline void MsgHdr::set_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:mhdr.MsgHdr.version)
}

// bool isReq = 20;
inline void MsgHdr::clear_isreq() {
  isreq_ = false;
}
inline bool MsgHdr::_internal_isreq() const {
  return isreq_;
}
inline bool MsgHdr::isreq() const {
  // @@protoc_insertion_point(field_get:mhdr.MsgHdr.isReq)
  return _internal_isreq();
}
inline void MsgHdr::_internal_set_isreq(bool value) {
  
  isreq_ = value;
}
inline void MsgHdr::set_isreq(bool value) {
  _internal_set_isreq(value);
  // @@protoc_insertion_point(field_set:mhdr.MsgHdr.isReq)
}

// uint32 rspCode = 30;
inline void MsgHdr::clear_rspcode() {
  rspcode_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MsgHdr::_internal_rspcode() const {
  return rspcode_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MsgHdr::rspcode() const {
  // @@protoc_insertion_point(field_get:mhdr.MsgHdr.rspCode)
  return _internal_rspcode();
}
inline void MsgHdr::_internal_set_rspcode(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  rspcode_ = value;
}
inline void MsgHdr::set_rspcode(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_rspcode(value);
  // @@protoc_insertion_point(field_set:mhdr.MsgHdr.rspCode)
}

// int32 method = 40;
inline void MsgHdr::clear_method() {
  method_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MsgHdr::_internal_method() const {
  return method_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MsgHdr::method() const {
  // @@protoc_insertion_point(field_get:mhdr.MsgHdr.method)
  return _internal_method();
}
inline void MsgHdr::_internal_set_method(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  method_ = value;
}
inline void MsgHdr::set_method(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_method(value);
  // @@protoc_insertion_point(field_set:mhdr.MsgHdr.method)
}

// string methodName = 50;
inline void MsgHdr::clear_methodname() {
  methodname_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& MsgHdr::methodname() const {
  // @@protoc_insertion_point(field_get:mhdr.MsgHdr.methodName)
  return _internal_methodname();
}
inline void MsgHdr::set_methodname(const std::string& value) {
  _internal_set_methodname(value);
  // @@protoc_insertion_point(field_set:mhdr.MsgHdr.methodName)
}
inline std::string* MsgHdr::mutable_methodname() {
  // @@protoc_insertion_point(field_mutable:mhdr.MsgHdr.methodName)
  return _internal_mutable_methodname();
}
inline const std::string& MsgHdr::_internal_methodname() const {
  return methodname_.Get();
}
inline void MsgHdr::_internal_set_methodname(const std::string& value) {
  
  methodname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void MsgHdr::set_methodname(std::string&& value) {
  
  methodname_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mhdr.MsgHdr.methodName)
}
inline void MsgHdr::set_methodname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  methodname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mhdr.MsgHdr.methodName)
}
inline void MsgHdr::set_methodname(const char* value,
    size_t size) {
  
  methodname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mhdr.MsgHdr.methodName)
}
inline std::string* MsgHdr::_internal_mutable_methodname() {
  
  return methodname_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* MsgHdr::release_methodname() {
  // @@protoc_insertion_point(field_release:mhdr.MsgHdr.methodName)
  return methodname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MsgHdr::set_allocated_methodname(std::string* methodname) {
  if (methodname != nullptr) {
    
  } else {
    
  }
  methodname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), methodname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mhdr.MsgHdr.methodName)
}

// .mhdr.RID toRID = 60;
inline bool MsgHdr::_internal_has_torid() const {
  return this != internal_default_instance() && torid_ != nullptr;
}
inline bool MsgHdr::has_torid() const {
  return _internal_has_torid();
}
inline void MsgHdr::clear_torid() {
  if (GetArena() == nullptr && torid_ != nullptr) {
    delete torid_;
  }
  torid_ = nullptr;
}
inline const ::mhdr::RID& MsgHdr::_internal_torid() const {
  const ::mhdr::RID* p = torid_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mhdr::RID*>(
      &::mhdr::_RID_default_instance_);
}
inline const ::mhdr::RID& MsgHdr::torid() const {
  // @@protoc_insertion_point(field_get:mhdr.MsgHdr.toRID)
  return _internal_torid();
}
inline void MsgHdr::unsafe_arena_set_allocated_torid(
    ::mhdr::RID* torid) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(torid_);
  }
  torid_ = torid;
  if (torid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mhdr.MsgHdr.toRID)
}
inline ::mhdr::RID* MsgHdr::release_torid() {
  
  ::mhdr::RID* temp = torid_;
  torid_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mhdr::RID* MsgHdr::unsafe_arena_release_torid() {
  // @@protoc_insertion_point(field_release:mhdr.MsgHdr.toRID)
  
  ::mhdr::RID* temp = torid_;
  torid_ = nullptr;
  return temp;
}
inline ::mhdr::RID* MsgHdr::_internal_mutable_torid() {
  
  if (torid_ == nullptr) {
    auto* p = CreateMaybeMessage<::mhdr::RID>(GetArena());
    torid_ = p;
  }
  return torid_;
}
inline ::mhdr::RID* MsgHdr::mutable_torid() {
  // @@protoc_insertion_point(field_mutable:mhdr.MsgHdr.toRID)
  return _internal_mutable_torid();
}
inline void MsgHdr::set_allocated_torid(::mhdr::RID* torid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete torid_;
  }
  if (torid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(torid);
    if (message_arena != submessage_arena) {
      torid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, torid, submessage_arena);
    }
    
  } else {
    
  }
  torid_ = torid;
  // @@protoc_insertion_point(field_set_allocated:mhdr.MsgHdr.toRID)
}

// .mhdr.RID fromRID = 70;
inline bool MsgHdr::_internal_has_fromrid() const {
  return this != internal_default_instance() && fromrid_ != nullptr;
}
inline bool MsgHdr::has_fromrid() const {
  return _internal_has_fromrid();
}
inline void MsgHdr::clear_fromrid() {
  if (GetArena() == nullptr && fromrid_ != nullptr) {
    delete fromrid_;
  }
  fromrid_ = nullptr;
}
inline const ::mhdr::RID& MsgHdr::_internal_fromrid() const {
  const ::mhdr::RID* p = fromrid_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mhdr::RID*>(
      &::mhdr::_RID_default_instance_);
}
inline const ::mhdr::RID& MsgHdr::fromrid() const {
  // @@protoc_insertion_point(field_get:mhdr.MsgHdr.fromRID)
  return _internal_fromrid();
}
inline void MsgHdr::unsafe_arena_set_allocated_fromrid(
    ::mhdr::RID* fromrid) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fromrid_);
  }
  fromrid_ = fromrid;
  if (fromrid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mhdr.MsgHdr.fromRID)
}
inline ::mhdr::RID* MsgHdr::release_fromrid() {
  
  ::mhdr::RID* temp = fromrid_;
  fromrid_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mhdr::RID* MsgHdr::unsafe_arena_release_fromrid() {
  // @@protoc_insertion_point(field_release:mhdr.MsgHdr.fromRID)
  
  ::mhdr::RID* temp = fromrid_;
  fromrid_ = nullptr;
  return temp;
}
inline ::mhdr::RID* MsgHdr::_internal_mutable_fromrid() {
  
  if (fromrid_ == nullptr) {
    auto* p = CreateMaybeMessage<::mhdr::RID>(GetArena());
    fromrid_ = p;
  }
  return fromrid_;
}
inline ::mhdr::RID* MsgHdr::mutable_fromrid() {
  // @@protoc_insertion_point(field_mutable:mhdr.MsgHdr.fromRID)
  return _internal_mutable_fromrid();
}
inline void MsgHdr::set_allocated_fromrid(::mhdr::RID* fromrid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete fromrid_;
  }
  if (fromrid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(fromrid);
    if (message_arena != submessage_arena) {
      fromrid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fromrid, submessage_arena);
    }
    
  } else {
    
  }
  fromrid_ = fromrid;
  // @@protoc_insertion_point(field_set_allocated:mhdr.MsgHdr.fromRID)
}

// .mhdr.Location toLoc = 80;
inline bool MsgHdr::_internal_has_toloc() const {
  return this != internal_default_instance() && toloc_ != nullptr;
}
inline bool MsgHdr::has_toloc() const {
  return _internal_has_toloc();
}
inline void MsgHdr::clear_toloc() {
  if (GetArena() == nullptr && toloc_ != nullptr) {
    delete toloc_;
  }
  toloc_ = nullptr;
}
inline const ::mhdr::Location& MsgHdr::_internal_toloc() const {
  const ::mhdr::Location* p = toloc_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mhdr::Location*>(
      &::mhdr::_Location_default_instance_);
}
inline const ::mhdr::Location& MsgHdr::toloc() const {
  // @@protoc_insertion_point(field_get:mhdr.MsgHdr.toLoc)
  return _internal_toloc();
}
inline void MsgHdr::unsafe_arena_set_allocated_toloc(
    ::mhdr::Location* toloc) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(toloc_);
  }
  toloc_ = toloc;
  if (toloc) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mhdr.MsgHdr.toLoc)
}
inline ::mhdr::Location* MsgHdr::release_toloc() {
  
  ::mhdr::Location* temp = toloc_;
  toloc_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mhdr::Location* MsgHdr::unsafe_arena_release_toloc() {
  // @@protoc_insertion_point(field_release:mhdr.MsgHdr.toLoc)
  
  ::mhdr::Location* temp = toloc_;
  toloc_ = nullptr;
  return temp;
}
inline ::mhdr::Location* MsgHdr::_internal_mutable_toloc() {
  
  if (toloc_ == nullptr) {
    auto* p = CreateMaybeMessage<::mhdr::Location>(GetArena());
    toloc_ = p;
  }
  return toloc_;
}
inline ::mhdr::Location* MsgHdr::mutable_toloc() {
  // @@protoc_insertion_point(field_mutable:mhdr.MsgHdr.toLoc)
  return _internal_mutable_toloc();
}
inline void MsgHdr::set_allocated_toloc(::mhdr::Location* toloc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete toloc_;
  }
  if (toloc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(toloc);
    if (message_arena != submessage_arena) {
      toloc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, toloc, submessage_arena);
    }
    
  } else {
    
  }
  toloc_ = toloc;
  // @@protoc_insertion_point(field_set_allocated:mhdr.MsgHdr.toLoc)
}

// repeated .mhdr.Location altToLocs = 90;
inline int MsgHdr::_internal_alttolocs_size() const {
  return alttolocs_.size();
}
inline int MsgHdr::alttolocs_size() const {
  return _internal_alttolocs_size();
}
inline void MsgHdr::clear_alttolocs() {
  alttolocs_.Clear();
}
inline ::mhdr::Location* MsgHdr::mutable_alttolocs(int index) {
  // @@protoc_insertion_point(field_mutable:mhdr.MsgHdr.altToLocs)
  return alttolocs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mhdr::Location >*
MsgHdr::mutable_alttolocs() {
  // @@protoc_insertion_point(field_mutable_list:mhdr.MsgHdr.altToLocs)
  return &alttolocs_;
}
inline const ::mhdr::Location& MsgHdr::_internal_alttolocs(int index) const {
  return alttolocs_.Get(index);
}
inline const ::mhdr::Location& MsgHdr::alttolocs(int index) const {
  // @@protoc_insertion_point(field_get:mhdr.MsgHdr.altToLocs)
  return _internal_alttolocs(index);
}
inline ::mhdr::Location* MsgHdr::_internal_add_alttolocs() {
  return alttolocs_.Add();
}
inline ::mhdr::Location* MsgHdr::add_alttolocs() {
  // @@protoc_insertion_point(field_add:mhdr.MsgHdr.altToLocs)
  return _internal_add_alttolocs();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mhdr::Location >&
MsgHdr::alttolocs() const {
  // @@protoc_insertion_point(field_list:mhdr.MsgHdr.altToLocs)
  return alttolocs_;
}

// .mhdr.Location fromLoc = 100;
inline bool MsgHdr::_internal_has_fromloc() const {
  return this != internal_default_instance() && fromloc_ != nullptr;
}
inline bool MsgHdr::has_fromloc() const {
  return _internal_has_fromloc();
}
inline void MsgHdr::clear_fromloc() {
  if (GetArena() == nullptr && fromloc_ != nullptr) {
    delete fromloc_;
  }
  fromloc_ = nullptr;
}
inline const ::mhdr::Location& MsgHdr::_internal_fromloc() const {
  const ::mhdr::Location* p = fromloc_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mhdr::Location*>(
      &::mhdr::_Location_default_instance_);
}
inline const ::mhdr::Location& MsgHdr::fromloc() const {
  // @@protoc_insertion_point(field_get:mhdr.MsgHdr.fromLoc)
  return _internal_fromloc();
}
inline void MsgHdr::unsafe_arena_set_allocated_fromloc(
    ::mhdr::Location* fromloc) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fromloc_);
  }
  fromloc_ = fromloc;
  if (fromloc) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mhdr.MsgHdr.fromLoc)
}
inline ::mhdr::Location* MsgHdr::release_fromloc() {
  
  ::mhdr::Location* temp = fromloc_;
  fromloc_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mhdr::Location* MsgHdr::unsafe_arena_release_fromloc() {
  // @@protoc_insertion_point(field_release:mhdr.MsgHdr.fromLoc)
  
  ::mhdr::Location* temp = fromloc_;
  fromloc_ = nullptr;
  return temp;
}
inline ::mhdr::Location* MsgHdr::_internal_mutable_fromloc() {
  
  if (fromloc_ == nullptr) {
    auto* p = CreateMaybeMessage<::mhdr::Location>(GetArena());
    fromloc_ = p;
  }
  return fromloc_;
}
inline ::mhdr::Location* MsgHdr::mutable_fromloc() {
  // @@protoc_insertion_point(field_mutable:mhdr.MsgHdr.fromLoc)
  return _internal_mutable_fromloc();
}
inline void MsgHdr::set_allocated_fromloc(::mhdr::Location* fromloc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete fromloc_;
  }
  if (fromloc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(fromloc);
    if (message_arena != submessage_arena) {
      fromloc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fromloc, submessage_arena);
    }
    
  } else {
    
  }
  fromloc_ = fromloc;
  // @@protoc_insertion_point(field_set_allocated:mhdr.MsgHdr.fromLoc)
}

// uint32 transID = 110;
inline void MsgHdr::clear_transid() {
  transid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MsgHdr::_internal_transid() const {
  return transid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MsgHdr::transid() const {
  // @@protoc_insertion_point(field_get:mhdr.MsgHdr.transID)
  return _internal_transid();
}
inline void MsgHdr::_internal_set_transid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  transid_ = value;
}
inline void MsgHdr::set_transid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_transid(value);
  // @@protoc_insertion_point(field_set:mhdr.MsgHdr.transID)
}

// string sid = 120;
inline void MsgHdr::clear_sid() {
  sid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& MsgHdr::sid() const {
  // @@protoc_insertion_point(field_get:mhdr.MsgHdr.sid)
  return _internal_sid();
}
inline void MsgHdr::set_sid(const std::string& value) {
  _internal_set_sid(value);
  // @@protoc_insertion_point(field_set:mhdr.MsgHdr.sid)
}
inline std::string* MsgHdr::mutable_sid() {
  // @@protoc_insertion_point(field_mutable:mhdr.MsgHdr.sid)
  return _internal_mutable_sid();
}
inline const std::string& MsgHdr::_internal_sid() const {
  return sid_.Get();
}
inline void MsgHdr::_internal_set_sid(const std::string& value) {
  
  sid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void MsgHdr::set_sid(std::string&& value) {
  
  sid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mhdr.MsgHdr.sid)
}
inline void MsgHdr::set_sid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  sid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mhdr.MsgHdr.sid)
}
inline void MsgHdr::set_sid(const char* value,
    size_t size) {
  
  sid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mhdr.MsgHdr.sid)
}
inline std::string* MsgHdr::_internal_mutable_sid() {
  
  return sid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* MsgHdr::release_sid() {
  // @@protoc_insertion_point(field_release:mhdr.MsgHdr.sid)
  return sid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MsgHdr::set_allocated_sid(std::string* sid) {
  if (sid != nullptr) {
    
  } else {
    
  }
  sid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mhdr.MsgHdr.sid)
}

// string traceID = 130;
inline void MsgHdr::clear_traceid() {
  traceid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& MsgHdr::traceid() const {
  // @@protoc_insertion_point(field_get:mhdr.MsgHdr.traceID)
  return _internal_traceid();
}
inline void MsgHdr::set_traceid(const std::string& value) {
  _internal_set_traceid(value);
  // @@protoc_insertion_point(field_set:mhdr.MsgHdr.traceID)
}
inline std::string* MsgHdr::mutable_traceid() {
  // @@protoc_insertion_point(field_mutable:mhdr.MsgHdr.traceID)
  return _internal_mutable_traceid();
}
inline const std::string& MsgHdr::_internal_traceid() const {
  return traceid_.Get();
}
inline void MsgHdr::_internal_set_traceid(const std::string& value) {
  
  traceid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void MsgHdr::set_traceid(std::string&& value) {
  
  traceid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mhdr.MsgHdr.traceID)
}
inline void MsgHdr::set_traceid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  traceid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mhdr.MsgHdr.traceID)
}
inline void MsgHdr::set_traceid(const char* value,
    size_t size) {
  
  traceid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mhdr.MsgHdr.traceID)
}
inline std::string* MsgHdr::_internal_mutable_traceid() {
  
  return traceid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* MsgHdr::release_traceid() {
  // @@protoc_insertion_point(field_release:mhdr.MsgHdr.traceID)
  return traceid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MsgHdr::set_allocated_traceid(std::string* traceid) {
  if (traceid != nullptr) {
    
  } else {
    
  }
  traceid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), traceid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mhdr.MsgHdr.traceID)
}

// repeated .mhdr.RouteInfo routes = 140;
inline int MsgHdr::_internal_routes_size() const {
  return routes_.size();
}
inline int MsgHdr::routes_size() const {
  return _internal_routes_size();
}
inline void MsgHdr::clear_routes() {
  routes_.Clear();
}
inline ::mhdr::RouteInfo* MsgHdr::mutable_routes(int index) {
  // @@protoc_insertion_point(field_mutable:mhdr.MsgHdr.routes)
  return routes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mhdr::RouteInfo >*
MsgHdr::mutable_routes() {
  // @@protoc_insertion_point(field_mutable_list:mhdr.MsgHdr.routes)
  return &routes_;
}
inline const ::mhdr::RouteInfo& MsgHdr::_internal_routes(int index) const {
  return routes_.Get(index);
}
inline const ::mhdr::RouteInfo& MsgHdr::routes(int index) const {
  // @@protoc_insertion_point(field_get:mhdr.MsgHdr.routes)
  return _internal_routes(index);
}
inline ::mhdr::RouteInfo* MsgHdr::_internal_add_routes() {
  return routes_.Add();
}
inline ::mhdr::RouteInfo* MsgHdr::add_routes() {
  // @@protoc_insertion_point(field_add:mhdr.MsgHdr.routes)
  return _internal_add_routes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mhdr::RouteInfo >&
MsgHdr::routes() const {
  // @@protoc_insertion_point(field_list:mhdr.MsgHdr.routes)
  return routes_;
}

// repeated .mhdr.RouteInfo vias = 150;
inline int MsgHdr::_internal_vias_size() const {
  return vias_.size();
}
inline int MsgHdr::vias_size() const {
  return _internal_vias_size();
}
inline void MsgHdr::clear_vias() {
  vias_.Clear();
}
inline ::mhdr::RouteInfo* MsgHdr::mutable_vias(int index) {
  // @@protoc_insertion_point(field_mutable:mhdr.MsgHdr.vias)
  return vias_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mhdr::RouteInfo >*
MsgHdr::mutable_vias() {
  // @@protoc_insertion_point(field_mutable_list:mhdr.MsgHdr.vias)
  return &vias_;
}
inline const ::mhdr::RouteInfo& MsgHdr::_internal_vias(int index) const {
  return vias_.Get(index);
}
inline const ::mhdr::RouteInfo& MsgHdr::vias(int index) const {
  // @@protoc_insertion_point(field_get:mhdr.MsgHdr.vias)
  return _internal_vias(index);
}
inline ::mhdr::RouteInfo* MsgHdr::_internal_add_vias() {
  return vias_.Add();
}
inline ::mhdr::RouteInfo* MsgHdr::add_vias() {
  // @@protoc_insertion_point(field_add:mhdr.MsgHdr.vias)
  return _internal_add_vias();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mhdr::RouteInfo >&
MsgHdr::vias() const {
  // @@protoc_insertion_point(field_list:mhdr.MsgHdr.vias)
  return vias_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace mhdr

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::mhdr::Transport> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mhdr::Transport>() {
  return ::mhdr::Transport_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_mhdr_2eproto
